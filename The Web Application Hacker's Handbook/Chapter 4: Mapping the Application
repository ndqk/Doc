Mapping the Application

----------------------------------------------------------------------------
* Enumerating Content and Functionality
 1. Web Spidering
 
 2. User-Directed Spidering
  - Hack Steps:
   1. Configure your browser to use either Burp or WebScarab as a local proxy
   2. Browse the entire application normally, attempting to visit every link/URL you discover, submitting every form, and proceeding through all multistep functions to completion. Try browsing with JavaScript enabled and disabled, and with cookies enabled and disabled. Many applications can handle various browser configurations, and you may reach different content and code paths within the application.
   3. Review the site map generated by the proxy/spider tool, and identify any application content or functions that you did not browse manually. Establish how the spider enumerated each item. For example, in Burp Spider, check the Linked From details. Using your browser, access the item manually so that the response from the server is parsed by the proxy/spider tool to identify any further content. Continue this step recursively until no further content or functionality is identified.
   4. Optinally, tell the tool to actively spider the site using all of the already enumerated content as a starting point. To do this, first identify any URLs that are dangerous or likely to break the application session, and configure the spider to exclude these from its scope. Run the spider and review the results for any additional content it discovers.
   The site map generated by the proxy/spider tool contains a wealth of information about the target application, which will be useful later in identifying the various attack surfaces exposed by the application.
 	
 3. Discovering Hidden Content
  - Brute-Force Techniques
   + Hack Steps:
    1. Make some manual requests for known valid and invalid resources, and identify how the server handles the latter.
    2. Use the site map generated through user-directed spidering as a basic for automated discovery of hidden content.
    3. Make automated requests for common filenames and directories within each directory or path known to exist within the application. Use Burp Intruder or a custom script, together with wordlists of common files and directories, to quickly generate large numbers of requests. If you have identified a particular way in which the application handles requests for invalid resources (such as a customized "file not found" page), configure Intruder or your script to highlight these results so that they can be ignored.
    4. Capture the responses received from the server, and manually review them to identify valid resources.
    5. Perform the exercise recursively as new content is discovered.
    
  - Inference from Published Content 
   + Hack Steps:
    1. Review the results of your user-directed browsing and basic brute-force exercises. Complite lists of the names of all enumerated subdirectories, file stems, and file extensions.
    2. Review these lists to identify any naming schemes in use. For example, if there are pages called AddDocument.jsp and ViewDocument.jsp, there may also be pages called EditDocument.jsp and RemoveDocument.jsp. You can often get a feel for developers' naming habits just by reading a few examples. For example, depending on their personal style, developers may be verbose (AddNewUser.asp), succinct (AddUser.asp), use abbreviations (AddUsr.asp), or even be more cryptic (AddU.asp). Getting a feel for the naming styles in use may help you guess the prcise names of content you have not already identified.
    3. Sometimes, the naming scheme used for different content employs identifiers such as numbers and dates, which can make inferring hidden content easy. This is most commonly encountered in the names of static resources, rather than dynamic scripts. For example, if a company's website links to AnnualReport2009.pdf and AnnualReport2010.pdf, it should be a short step to identifying what the next report will be called. Somewhat incredibly, there have been notorious cases of companies placing files containing financial reports on their web servers before they were publicly announced, only to have wily journalists discover them based on the naming scheme used in earlier years.
    4. Review all client-side code such as HTML and JavaScript to identify any clues about hidden server-side content. These may include HTML comments related to protected or unlinked functions, HTML forms with disabled SUBMIT elements, and the like. Often, comments are automatically generated by the software that has been used to generate web content, or by the platform on which the application is running. References to items such as server-side include files are of particular interest. These files may actually be publicly downloadable and may contain hightly sensitive information such as database connection strings and password. In other cases, developers' comments may contain all kinds of useful tidbits, such as database names, references to back-end components, SQL query string, and so on. Thick-client components such as Java applets and ActiveX controls may also contain sentitive data that you can extract.
    5. Add to the lists of enumerated items any further potential names conjectured on the basic of the items that you have discovered. Also add to the file extension list common extensions such as txt, bak, src, inc and old, which may uncover the source to backup versions of live pages. Also add extensions associated with the development languages in use, such as .java and .cs, which may uncover source files that have been compiled into live pages.
    6. Search for temporary files that may have been created inadvertently by developer tools and file editors. Examples include the .DS_Store file, which contains a directory index under OS X, file.php~1, which is a temporary file created when file.php is edited, and the .tmp file extension that is used by numerous software tools.
    7. Perform further automated exercises, combining the lists of directories, file stems, and file extensions to request large numbers of potential resources. For example, in a given directory, request each file stem combined with each file extension. Or request each directory name as a subdirectory of every known directory.
    8. Where a consistent naming scheme has been identified, consider performing a more focused brute-force exercise. For example, if AddDocument.jsp and ViewDocument.jsp are known to exist, you may create a list of actions (edit, delete, create) and make requests of the form XxxDocument.jsp. Alternatively , create a list of item types (user, account, file) and make requests of the form AddXxx.jsp.
    9. Perform each exercise recursively, using new numerated content and patterns as the basic for further user-directed spidering and further automated content discovery. You are limited only by your imagination, time available, and the importance you attach to discovering hidden content within the application you are targeting.
    
  - Use of Public Information
   + Hack Steps:
    1. Use serveral different seach engines and web archives to discover what content they indexed or stored for the application you are attacking.
    2. When querying a search engine, you can use various advanced techniques to maximize the effectiveness of you research. The following suggestions apply to Google. You can find the corresponding queries on other engines by selecting their Advanced Search option.
     _ site: www.wahh-target.com | returns every resource within the target site that Google has a reference to.
     _ site: www.wahh-target.com login | returns all the pages containing the expression login. In a large and complex application, this technique can be used to quickly home in on interesting resources, such as site mapps, password reset functions, and administrative menus.
     _ link: www.wahh-target.com | returns all the pages on other websites and applications that contain a link to the target. This may include links to old content, or functionality that is intended for use only by third parties, such as partner links.
     _ related: www.wahh-target.com | returns pages that are "similar" to the target and there for includes a lot of irrelevant material. However, it may also discuss the target on other sites, which may be of interest.
    3. Perform each search not only in the default Web section of Google, but also in Groups and News, which may contain different results.
    4. Browse to the last page of search results for a given query, and select Repeat the Search with the Ommited Results Included. By default, Google attempts to filter out redundant results by removing pages that it believes are sufficiently similar to others included in the results. Overriding this behavior may uncover subtly different pages that are of interest to you when attacking the application.
    5. View the cached version of interesting pages, including any content that is no longer present in the actual application. In some cases, search engine caches contain resources that connot be directly accessed in the application without authentication or payment.
    6. Perform the same queries on other domain names belonging to the same organization, which may contain useful information about the application you are targeting.
    If your research identifies old content and functionality that is no longer linked to within the main application, it may still be present and usable. The old functionality may contain vulnerabilities that do not exist elsewhere within the application.
    Even where old content has been removed from the live application, the content obtained from a search engine cache or web archive may contain references to or clues about other functionality that is still present within the live application and that can be used to attack it.
    
   + Hack Steps:
    1. Compile a list containing every name andd e-mail address you can discover relating to the target application and its development. This should include any known developers, names found within HTML source code, names found in the contact information section of the main company website, and any names disclosed within the application itselft, such as administrative staff.
    2. Using the search techniques described previously, search for each identified name to find any questions and answers they have posted to Internet forums. Review any infomation found for clues about functionality or vulnerabilities within the target application.
    
  - Leveraging the Web Server
   + Hack Steps:
    Several useful options are available when you run Nikto:
    1. If you believe that the server is using a nonstandard location for interesting content that Nikto checks for (such as /cgi/cgi-bin instead of /cgi-bin), you can specify this alternative location using the option --root/cgi/. For the specific case of CGI directories, these can also be specified using the option -Cgidirs.
    2. If the site uses a custom "file not found" page that does not return the HTTP 404 status code, you can specify a particular string that identifies this page by using the -404 option.
    3. Be aware that Nikto does not perform any intelligent verification of potential issues and therefore is prone to report false positives. Always check any results Nikto returns manually.
    Note that with tools like Nikto, you can specify a target application using its domain name or IP address. If a tool accesses a page using its IP address, the tool treats links on that page that use its domain name as belonging to a different domain, so the links are not followed. This is reasonable, because some applications are virtually hosted, with multiple domain names sharing the same IP address. Ensure that you configure your tools with this face in mind.
 
 4. Application Pages Versus Functional Paths
  - Hack Steps:
   1. Identify any instances where application functionality is accessed not by requesting a specific page for that function (such as /admin/editUser.jsp) but passing the name of a function in a paramater (such as /admin.jsp?action=editUser).
   2. Modify the automated techniques described for discovering URL-specified content to work on the content-access mechanisms in use within the application. For example, if the application uses paramaters that specify servlet and method names, first determine its behavior when an invalid servlet and/or method is requested, and when a valid method is requested with other invalid paramaters. Try to identify attributes of the server's responses that indicate "hits" - valid servlets and methods. If possible, find a way of attacking the problem in two statges, first enumerating servlets and then methods within these. Using a method similar to the one used for URL-specified content, compile lists of common items, add to these by inferring from the names actually observed, and generate large numbers of requests based on these.
   3. If applicable, compile a map of application content based on functional paths, showing all the enumerated functions and the logical paths and dependencies between them.
   
 5. Discovering Hidden Parameters
  - Hack Steps:
   1. Using lists of common debug parameter names (debug, test, hide, source, etc.) and common values (true, yes, on, 1, etc.), make a large number of requests to a know application page or function, iterating through all permutations of name and value. For POST requests, insert the added parameter to both the URL query string and the message body.
   Burp Intruder can be used to perform this test using multiple payload sets and the "cluster bomb" attack type.
   2. Monitor all responses received to identify any anomalies that may indicate that the added parameter has had an effect on the application's processing.
   3. Depending on the time available, target a number of different pages or functions for hidden parameter discovery. Choose functions where it is most likely that developers have implemented debug logic, such as login, search, and file uploadfing and downloading.
   
-------------------------------------------------------------
* Analyzing the Application
 1. Identifying Entry Points for User Input
  - URL File Paths
  - Request Parameters
  - HTTP Headers
  - Out-of-Band Channels
 
 2. Identifying Server-Side Technologies
  - Banner Grabbing
  - HTTP Fingerprinting
  - File Extensions
  - Directory Names
  - Session Tokens
  - Third-Party Code Components
  
  HACK STEPS:
   1. Identify all entry points for user input, including URLs, query string parameters, POST data, cookies, and other HTTP headers processed by the application.
   2. Examine the query string format used by the application. If it does not employ the standard format described in Chapter 3, try to understand how paramaters are being transmitted via the URL. Virtually all custom schemes still employ some variation on the name/value model, so try to understand how name/value pairs are begin encapsulated into the non-standard URLs you have identified.
   3. Identify any out-of-bound channels via which user-controllable or other third-party data is begin introduced into the application's processing.
   4. View the HTTP Server banner returned by the application. Note that in some cases, different areas of the application are handled by different back-end components, so different Server headers may be received.
   5. Check for any other software identifier contained within any custom HTTP headers or HTML source code comments.
   6. Run the httprint tool to fingerprint the web server.
   7. If fine-grained information is obtained about the web server and other components, research the software versions in use to identify any vulnerabilities that may be exploited to advance an attack.
   8. Review your map of application URLs to identify any interesting-looking file extension, directories, or other sub-sequences that may provide clues about the technologies in use on the server.
   9. Review the names of all session tokens issued by the application to identify the technologies being used.
   10. Use lists of common technologies, or Google, to establish which technologies may be un use on the server, or discover other websites and applications that appert to employ the same technologies.
   11. Perform searches on Google for the names of any unusual cookies, scripts, HTTP headers, and the like that may belong to third-party software components. If you locate other applications in which the same components are being used, review these to identify any addtional functionality and parameters that the components support, and verify whether these are also present in your target application. Note that third-party components may look and feel quite different in each inplementation, due to branding customizations, but the core functionality, including srcipt and parameter names, is often the same. If possible, download and install the component and analyze it to fully understand its capabilities and, if possible, discover any vulnerabilities. Consult repositories of known vulnerabilities to identify any known defects with the component in question.

 3. Identifying Server-Side Functionality
  - Dissectiong Requests
   + HACK STEPS:
    1. Review the names and values of all parameters being submitted to the application in the context of the functionality they support
    2. Try to think like a programmer, and imagine what server-side mechanisms and technologies are likely to have been used to implement the behavior you can observe.
    
  - Extrapolating Application Behavior
   + HACK STEPS:
    1. Try to identify any locations within the application that may contain clues about the internal structure and functionality of other areas.
    2. It may not be possible to draw any firm conclusions here; however, the cases identified may prove useful at a later stage of the attack when you're attempting to exploit any potential vulnerabilities.
  
  - Isolating Unique Application Behavior
   + HACK STEPS:
    1. Make a not of any functionality that diverges from the standard GUI appearance, parameter naming, or navigation mechanism used within the rest of the application.
    2. Also make a note of functionality that likely to have been added retro-spectively. Example include debug functions, CAPTCHA controls, usage tracking, and third-party code.
    3. Perform a full review of these areas, and do not assume that the standard defenses used elsewhere in the application apply.

 4. Mapping the Attack Surface
  - HACK STEPS:
   1. Understand the core functionality implemented within the application and the main security mechanisms in use.
   2. Identify all features of the application's functionality and behavior that are often associated with common vulnerabilities,
   3. Check any third-party code against public vulnerability databases such as www.osvdb.org to determine any known issues.
   4. Formulate a plan of attack, prioritizing the most interesting-looking functionality and the most serious of the associated potential vulnerabilities.
     
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
