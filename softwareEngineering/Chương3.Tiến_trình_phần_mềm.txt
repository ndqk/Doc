	Tiến trình phần mềm là cách chúng ta sản xuất phần mềm. Nó kết hợp phương pháp luận (Phần 1.11) với mô hình vòng đời phần mềm cơ bản (Chương 2) và các kỹ thuật, các công cụ chúng ta sử dụng (Phần 5.6 đến 5.12) và quan trọng nhất là các cá nhân xây dựng phần mềm.
	Các tổ chức khác nhau có các tiến trình phần mềm khác nhau. Ví dụ, hãy xem xét vấn đề tài liệu. Một số tổ chức coi phần mềm mà họ sản xuất là tự lập tài liệu; có nghĩa là, sản phẩm có thể được hiểu một cách đơn giản bằng cách đọc mã nguồn. Tuy nhiên, các tổ chức khác có tài liệu chuyên sâu. Họ nhanh chóng vẽ ra các đặc tả và kiểm tra chúng một cách có phương pháp. Sau đó, họ thực hiện các hoạt động thiết kế một cách cẩn thận, kiểm tra và kiểm tra lại các thiết kế của họ trước khi bắt đầu viết mã, và đưa ra những mô tả sâu rộng về từng code artifacts cho các lập trình viên. Các test case được lập kế hoạch trước, kết quả của mỗi lần kiểm thử được ghi lại và dữ liệu kiểm thử được lưu trữ một cách tỉ mỉ. Sau khi sản phẩm đã được giao và cài đặt trên máy tính của khách hàng, mọi đề xuất thay đổi phải được đề xuất bằng văn bản kèm theo lý do chi tiết để thực hiện thay đổi. Thay đổi chỉ có thể được thực hiện khi có ủy quyền bằng văn bản và sửa đổi không được tích hợp vào sản phẩm cho đến khi tài liệu được cập nhật và các thay đổi đối với tài liệu được chấp thuận.
	
	Cường độ kiểm thử là một thước đo khác mà các tổ chức có thể được so sánh. Một số tổ chức dành tới một nửa ngân sách phần mềm của họ để kiểm tra phần mềm, trong khi những tổ chức khác cảm thấy rằng chỉ người dùng mới có thể kiểm tra kỹ lưỡng một sản phẩm. Do đó, một số công ty dành rất ít thời gian và nỗ lực để kiểm thử sản phẩm nhưng lại dành một lượng thời gian đáng kể để khắc phục các sự cố do người dùng báo cáo. 
	
	Bảo trì sau giao hàng là mối bận tâm lớn của nhiều tổ chức phần mềm. Phần mềm 10, 15 hoặc thậm chí 20 năm tuổi liên tục được cải tiến để đáp ứng các nhu cầu thay đổi; Ngoài ra, các lỗi còn sót lại tiếp tục xuất hiện, ngay cả sau khi phần mềm đã được bảo trì thành công trong nhiều năm. Hầu như tất cả các tổ chức chuyển phần mềm của họ sang phần cứng mới hơn sau mỗi 3 đến 5 năm; điều này cũng cấu thành bảo trì sau giao hàng. 
	
	Ngược lại, các tổ chức khác về cơ bản chỉ quan tâm đến nghiên cứu, để lại sự phát triển - chưa nói đến việc bảo trì - cho những người khác. Điều này đặc biệt áp dụng cho các khoa khoa học máy tính của trường đại học, nơi sinh viên tốt nghiệp xây dựng phần mềm để chứng minh rằng một thiết kế hoặc kỹ thuật cụ thể là khả thi. Việc khai thác thương mại của khái niệm đã được xác nhận sẽ được giao cho các tổ chức khác. (Xem Chỉ trong trường hợp bạn muốn biết Hộp 3.1 về sự khác biệt rộng rãi trong cách các tổ chức khác nhau phát triển phần mềm.)
	
	Tuy nhiên, bất kể tiến trình chính xác là gì, tiến trình phát triển phần mềm được cấu trúc xung quanh năm quy trình công việc của Hình 2.4: yêu cầu, phân tích (đặc tả), thiết kế, cài đặt và kiểm thử. Trong chương này, các quy trình làm việc này được mô tả, cùng với những thách thức tiềm ẩn có thể phát sinh trong mỗi quy trình làm việc. Giải pháp cho những thách thức liên quan đến việc sản xuất phần mềm thường là không nhỏ, và phần còn lại của cuốn sách này được dành để mô tả các kỹ thuật phù hợp. Trong phần đầu tiên của chương này, chỉ những thách thức được nêu bật, nhưng người đọc sẽ được hướng dẫn đến các phần hoặc chương có liên quan để tìm giải pháp. Theo đó, phần này của chương không chỉ là tổng quan về tiến trình phần mềm mà còn là hướng dẫn cho phần lớn phần còn lại của cuốn sách. Chương này kết thúc với các sáng kiến ​​quốc gia và quốc tế để cải thiện tiến trình phần mềm.
	Bây giờ chúng ta kiểm tra Quy trình Unified.
	
//Box 3.1
Tại sao tiến trình phần mềm lại khác nhau rất nhiều giữa các tổ chức? Một lý do chính là thiếu kỹ năng kỹ thuật phần mềm. Rất nhiều chuyên gia phần mềm chỉ đơn giản là không cập nhật thường xuyên. Họ tiếp tục phát triển phần mềm Ye Olde Fashioned Way, bởi vì họ không còn cách nào khác.

Một lý do khác dẫn đến sự khác biệt trong tiến trình phần mềm là nhiều nhà quản lý phần mềm là những nhà quản lý xuất sắc nhưng lại biết rất ít về phát triển hoặc bảo trì phần mềm. Sự thiếu hiểu biết về kỹ thuật của họ có thể dẫn đến việc dự án bị chậm tiến độ đến mức không có ích lợi gì để tiếp tục. Điều này thường xuyên là lý do tại sao nhiều dự án phần mềm không bao giờ được hoàn thành.

Tuy nhiên, một lý do khác cho sự khác biệt giữa các tiến tr là cách nhìn của quản lý. Ví dụ, một tổ chức có thể quyết định rằng tốt hơn hết là nên giao sản phẩm đúng hạn, ngay cả khi sản phẩm đó không được kiểm tra đầy đủ. Với những trường hợp giống hệt nhau, một tổ chức khác có thể kết luận rằng rủi ro khi phân phối sản phẩm đó mà không có kiểm thử toàn diện sẽ lớn hơn nhiều so với việc dành thời gian để kiểm tra sản phẩm kỹ lưỡng và do đó giao hàng muộn.


1. The Unified Process
	Như đã trình bày ở đầu chương này, phương pháp luận là một thành phần của tiến trình phần mềm. Phương pháp hướng đối tượng chính ngày nay là Unified Process. Như đã giải thích trong Chỉ trong trường hợp bạn muốn biết ở Box 3.2, Unified “Process” thực sự là một phương pháp, nhưng tên Phương pháp hợp nhất đã được sử dụng làm tên của phiên bản đầu tiên của Ngôn ngữ tạo mô hình hợp nhất (Unified Modeling Language - UML). Ba phương pháp tiền thân của Unified Process (OMT, Booch’s method và Objectory) không còn được hỗ trợ và các phương pháp hướng đối tượng khác đã có rất ít hoặc không có. Do đó, Unified Process thường là lựa chọn chính ngày nay để sản xuất phần mềm hướng đối tượng. May mắn thay, như sẽ được trình bày trong Phần B của cuốn sách này, Unified Process là một phương pháp luận hướng đối tượng tuyệt vời về mọi mặt.
	
	Unified Process không phải là một chuỗi các bước cụ thể, mà nếu tuân theo, sẽ dẫn đến việc xây dựng được một sản phẩm phần mềm. Trên thực tế, không có phương pháp luận “one size fits ” như vậy có thể tồn tại vì có rất nhiều loại sản phẩm phần mềm. Ví dụ: có nhiều lĩnh vực ứng dụng khác nhau, chẳng hạn như bảo hiểm, hàng không vũ trụ và sản xuất. Ngoài ra, phương pháp để đưa gói COTS ra thị trường trước các đối thủ cạnh tranh khác với phương pháp được sử dụng để xây dựng mạng chuyển tiền điện tử có độ bảo mật cao. Ngoài ra, kỹ năng của các chuyên gia phần mềm có thể rất khác nhau.
	
	Thay vào đó, Unified Process nên được xem như một phương pháp luận có thể thích ứng. Đó là, nó được sửa đổi cho sản phẩm phần mềm cụ thể được phát triển. Như sẽ thấy trong Phần B, một số tính năng của Unified Process không thể áp dụng cho phần mềm quy mô vừa và nhỏ. Tuy nhiên, phần lớn Unified Process được sử dụng cho các sản phẩm phần mềm thuộc mọi quy mô. Cuốn sách này nhấn mạnh vào tập con chung này của Unified Process, nhưng các khía cạnh của Unified Process chỉ áp dụng cho phần mềm quy mô lớn cũng được thảo luận, để đảm bảo rằng các vấn đề cần được giải quyết khi các sản phẩm phần mềm lớn hơn được xây dựng được triệt để. đánh giá cao.
	
//Box 3.2
	Cho đến gần đây, các phương pháp luận phát triển phần mềm hướng đối tượng phổ biến nhất là kỹ thuật mô hình hóa đối tượng (object modeling technique - OMT) [Rumbaugh et al., 1991] và Grady Booch’s method [Booch, 1994]. OMT được phát triển bởi Jim Rumbaugh và nhóm của ông tại Trung tâm Nghiên cứu và Phát triển General Electric ở Schenectady, New York, trong khi Grady Booch phát triển phương pháp của mình tại Rational, Inc., ở Santa Clara, California. Tất cả các phương pháp luận phát triển phần mềm hướng đối tượng về cơ bản là tương đương nhau, do đó, sự khác biệt giữa phương pháp của OMT và Booch là rất nhỏ. Tuy nhiên, luôn có sự cạnh tranh thân thiện giữa những người ủng hộ hai phe.
	Điều này đã thay đổi vào tháng 10 năm 1994, khi Rumbaugh gia nhập Booch tại Rational. Hai nhà phương pháp ngay lập tức bắt đầu làm việc cùng nhau để phát triển một phương pháp kết hợp OMT và phương pháp của Booch. Khi phiên bản sơ bộ của công trình của họ được xuất bản, người ta chỉ ra rằng họ đã không phát triển một phương pháp luận mà chỉ đơn thuần là một ký hiệu để đại diện cho một sản phẩm phần mềm hướng đối tượng. Tên Unified Methodology nhanh chóng được đổi thành Unified Modeling Language(UML). Năm 1995, họ được tham gia tại Rational bởi Ivar Jacobson, tác giả của phương pháp luận Objectory. Booch, Jacobson và Rumbaugh, được gọi một cách trìu mến là “Three Amigos” (theo tên bộ phim Three Amigos năm 1986 của John Landis với Chevy Chase và Steve Martin), sau đó đã làm việc cùng nhau. Phiên bản 1.0 của UML, được xuất bản vào năm 1997, đã làm điên đảo thế giới kỹ thuật phần mềm. Cho đến lúc đó, chưa có ký hiệu nào được chấp nhận rộng rãi cho việc phát triển một sản phẩm phần mềm. Hầu như chỉ qua một đêm UML đã được sử dụng trên toàn thế giới. Nhóm Quản lý Đối tượng (Object Management Group - OMG), một hiệp hội của các công ty hàng đầu thế giới về công nghệ đối tượng, đã chịu trách nhiệm tổ chức một tiêu chuẩn quốc tế cho UML, để mọi chuyên gia phần mềm sẽ sử dụng cùng một phiên bản UML, do đó thúc đẩy giao tiếp giữa các cá nhân trong một tổ chức cũng như các công ty trên toàn thế giới. UML [Booch, Rumbaugh và Jacobson, 1999] ngày nay là ký hiệu tiêu chuẩn quốc tế không cần bàn cãi để đại diện cho các sản phẩm phần mềm hướng đối tượng.
	Điểm số của dàn nhạc cho biết nhạc cụ nào cần thiết để chơi bản nhạc, các nốt nhạc cần chơi và thời điểm chơi chúng, cũng như toàn bộ thông tin kỹ thuật như ký hiệu phím, nhịp độ và độ lớn. Thông tin này có thể được đưa ra bằng tiếng Anh, chứ không phải là một sơ đồ? Có thể, nhưng sẽ không thể chơi nhạc từ một mô tả như vậy. Ví dụ, không có cách nào một nghệ sĩ dương cầm và một nghệ sĩ vĩ cầm có thể biểu diễn một bản nhạc được mô tả như sau: “Bản nhạc đang ở thời gian hành khúc, ở phím B thứ. Ô nhịp đầu tiên bắt đầu bằng chữ A ở trên giữa C trên vĩ cầm (nốt một phần tư). Trong khi nốt này đang được chơi, nghệ sĩ dương cầm chơi một hợp âm bao gồm bảy nốt. Tay phải chơi bốn nốt sau: E nhọn trên C giữa. . . ”
	Rõ ràng rằng, trong một số lĩnh vực, mô tả dạng văn bản đơn giản không thể thay thế một sơ đồ. Âm nhạc là một trong những lĩnh vực như vậy; phát triển phần mềm là một lĩnh vực khác. Và để phát triển phần mềm, ngôn ngữ mô hình hóa tốt nhất hiện nay là UML.
	Làm điên đảo thế giới kỹ thuật phần mềm bằng UML là không đủ đối với Three Amigos. Nỗ lực tiếp theo của họ là xuất bản một phương pháp luận phát triển phần mềm hoàn chỉnh thống nhất ba phương pháp luận riêng biệt của họ. Phương pháp thống nhất này lần đầu tiên được gọi là Rational Unified Process(RUP); Rational có tên trong phương pháp luận không phải vì Three Amigos coi tất cả các cách tiếp cận khác là phi lý, mà bởi vì vào thời điểm đó cả ba đều là quản lý cấp cao của Rational, Inc. (Rational được IBM mua lại vào năm 2003). Trong cuốn sách của họ về RUP [Jacobson, Booch, và Rumbaugh, 1999], tên Unified Software Development Process (USDP) đã được sử dụng. Thuật ngữ Unified Process thường được sử dụng ngày nay, cho ngắn gọn.

2. Lặp và Tăng trong mô hình hướng đối tượng
	Mô hình hướng đối tượng sử dụng mô hình hóa xuyên suốt. Model(Mô hình) là một tập hợp các biểu đồ UML đại diện cho một hoặc nhiều khía cạnh của sản phẩm phần mềm sẽ được phát triển. (Các sơ đồ UML được giới thiệu trong Chương 7.) Nhớ lại rằng UML là viết tắt của Unified Modeling Language. Có nghĩa là, UML là công cụ mà chúng tôi sử dụng để đại diện (mô hình hóa) sản phẩm phần mềm mục tiêu. Một lý do chính cho việc sử dụng một biểu diễn đồ họa như UML được thể hiện tốt nhất bằng câu tục ngữ cổ, một bức tranh có giá trị bằng một ngàn lời nói. Biểu đồ UML cho phép các chuyên gia phần mềm giao tiếp với nhau nhanh hơn và chính xác hơn so với việc chỉ sử dụng mô tả bằng lời nói.
	
	Mô hình hướng đối tượng là một phương pháp luận lặp đi lặp lại và tăng dần. Mỗi dòng công việc bao gồm một số bước và để thực hiện luồng công việc đó, các bước của luồng công việc được thực hiện lặp lại cho đến khi các thành viên của nhóm phát triển hài lòng rằng họ có một mô hình UML chính xác của sản phẩm phần mềm mà họ muốn phát triển. Có nghĩa là, ngay cả những chuyên gia phần mềm có kinh nghiệm nhất cũng lặp đi lặp lại và nhắc lại cho đến khi cuối cùng họ hài lòng rằng các sơ đồ UML là chính xác. Hàm ý là các kỹ sư phần mềm, cho dù họ có xuất sắc đến đâu, hầu như không bao giờ có được các sản phẩm công việc khác nhau ngay lần đầu tiên. Làm sao có thể?
	Bản chất của các sản phẩm phần mềm là hầu như mọi thứ phải được phát triển lặp đi lặp lại và tăng dần. Xét cho cùng, các kỹ sư phần mềm là con người và do đó tuân theo Luật Miller (Phần 2.5). Có nghĩa là, không thể xem xét tất cả mọi thứ cùng một lúc, vì vậy ban đầu chỉ cần xử lý khoảng bảy khối (đơn vị thông tin). Sau đó, khi tập hợp các phần tiếp theo được xem xét, sẽ có thêm kiến ​​thức về sản phẩm phần mềm mục tiêu và các sơ đồ UML được sửa đổi dựa trên thông tin bổ sung này. Quá trình tiếp tục theo cách này cho đến khi cuối cùng các kỹ sư phần mềm hài lòng rằng tất cả các mô hình cho một quy trình làm việc nhất định đều đúng. Nói cách khác, ban đầu các sơ đồ UML tốt nhất có thể được vẽ dựa trên kiến ​​thức có sẵn ở đầu quy trình làm việc. Sau đó, khi có thêm kiến ​​thức về hệ thống trong thế giới thực đang được mô hình hóa, các sơ đồ được tạo ra chính xác hơn (lặp lại) và mở rộng (tăng dần). Do đó, cho dù một kỹ sư phần mềm có kinh nghiệm và kỹ năng như thế nào, anh ta hoặc cô ta lặp đi lặp lại nhiều lần và tăng dần cho đến khi hài lòng rằng các sơ đồ UML là sự thể hiện chính xác của sản phẩm phần mềm sẽ được phát triển.
	
	Theo lý thuyết,vào cuối cuốn sách này, người đọc sẽ có các kỹ năng kỹ thuật phần mềm cần thiết để xây dựng các sản phẩm phần mềm lớn, phức tạp mà Unified Process đã được phát triển. Thật không may, có ba lý do tại sao điều này không khả thi.
	1. Cũng như không thể trở thành chuyên gia về giải tích hoặc ngoại ngữ trong một khóa học duy nhất, để đạt được năng lực trong Unified Process đòi hỏi phải nghiên cứu 	sâu rộng và quan trọng hơn là thực hành không ngừng trong kỹ thuật phần mềm hướng đối tượng.
2. Unified Process được tạo ra chủ yếu để sử dụng trong việc phát triển các sản phẩm phần mềm lớn, phức tạp. Để có thể xử lý nhiều phức tạp của các sản phẩm phần mềm như vậy, bản thân Unified Process là rất lớn. Thật khó để trình bày mọi khía cạnh của Tiến trình Thống nhất trong một cuốn sách giáo khoa cỡ này.
	3. Để dạy Unified Process, cần trình bày một nghiên cứu tình huống minh họa các tính năng của Unified Process. Để minh họa các tính năng áp dụng cho các sản phẩm phần mềm lớn, một nghiên cứu điển hình như vậy sẽ phải lớn. Ví dụ: chỉ các đặc tả thường sẽ chiếm hơn 1000 trang.
	Vì ba lý do này, cuốn sách này trình bày hầu hết, nhưng không phải tất cả, về Tiến trình Hợp nhất.
	Các quy trình làm việc cốt lõi của Unified Process (quy trình yêu cầu, luồng công việc phân tích, luồng công việc thiết kế, quy trình thực hiện và quy trình kiểm tra) và những thách thức của chúng hiện đã được thảo luận.

3. Luồng công việc xác định yêu cầu
	Phát triển phần mềm rất tốn kém. Quá trình phát triển thường được bắt đầu khi khách hàng tiếp cận 1 tổ chức phát triển với 1 sản phẩm phần mềm mà khách hàng cho là cần cho lợi nhuận của doanh nghiệp của họ. Mục tiêu của quy trình xác định yêu cầu là để cho tổ chức phát triển xác định khách hàng cần gì. Nhiệm vụ đầu tiên của nhóm phát triển là đạt được những hiểu biết cơ bản về miền ứng dụng, hay là lĩnh vực mà sản phẩm sẽ hoạt động. Lĩnh vực này có thể là ngân hàng, sản xuất ô tô hay vật lý hạt nhân.
	
	Tại bất kì giai đoạn nào của tiến trình, nếu khách hàng không còn tin rằng phần mềm sẽ hiệu quả về mặt chi phí, thì việc phát triển sẽ chấm dứt ngay lập tức. Trong suốt chương này, giả định được đưa ra là khách hàng cảm thấy chi phí là hợp lý. Do đó, 1 khía cạnh quan trọng của phát triển phần mềm là "mô hình kinh doanh/mô hình nghiệp vụ", 1 tài liệu chứng minh hiệu quả chi phí của sản phẩm.(Thực tế, "chi phí" không phải lúc nào cũng là tài chính. Ví dụ: phần mềm quân sự thường được xây dựng vì các lý do chiến thuật. Ở đây, chi phí của phần mềm là thiệt hại tiềm tàng có thể phải chịu khi vũ khí không được phát triển).
	
	Tại cuộc họp đầu tiên giữa khách hàng và nhà phát triển, khách hàng phác thảo sản phẩm mà họ đã lên ý tưởng. Theo quan điểm của các nhà phát triển, mô tả của khách hàng về sản phẩm mong muốn có thể mơ hồ, không hợp lý, mâu thuẫn, hoặc đơn giản là không thể đạt được. Nhiệm vụ của nhà phát triển ở giai đoạn này là xác định chính xác những gì khách hàng cần và tìm ra từ khách hàng những ràng buộc nào tồn tại.
	- Một ràng buộc chính là thời hạn giao sản phẩm (Deadline). VD: Khách hàng có thể quy định rằng sản phẩm hoàn chỉnh phải được hoàn thành trong vòng 14 tháng. Trong hầu hết các lĩnh vực ứng dụng, việc giao sản phẩm trở thành nhiệm vụ quan trọng. Có nghĩa là, khách hàng cần sản phẩm phần mềm cho các hoạt động cốt lõi cho tổ chức của họ và bất kỳ sự chậm trễ nào đề gây bất lợi cho tổ chức.
	- Nhiều rằng buộc khác thường xuất hiện, chẳng hạn như độ tin cậy (reliability) (VD: sản phẩm phải hoạt động 99% thời gian, hoặc thời gian trung bình giữa các lần hòng phải ít nhất 4 tháng). Một ràng buộc phổ biến khác là kích thước của hình ảnh được tải (VD: nó phải chạy trên máy tính cá nhân của khách hàng hoặc trên phần cứng bên trong vệ tinh).
	- Chi phí (Cost) luôn luôn là một ràng buộc quan trọng. Tuy nhiên, khách hàng hiếm khi cho các nhà phát triển biết có bao nhiêu tiền để xây dựng phần mềm. Thay vào đó, một thực tế phổ biến là, khi các đặc tả được hoàn thiện, khách hàng yêu cầu các nhà phát triển nêu rõ giá để hoàn thành dự án. Khách hàng tuân theo thủ tục đấu thầu này với hy vọng rằng số tiền nhà phát triển bỏ thầu thấp hơn số tiền khách hàng lên ngân sách cho dự án.
	
	Cuộc điều tra sơ bộ về nhu cầu của khách hàng đôi khi được gọi là thăm dò ý tưởng(concept exploration). Trong các cuộc họp tiếp theo giữa các thành viên nhóm phát triển và nhóm khách hàng, chức năng của sản phẩm liên tục được tinh chỉnh và phân tích để xác định tính khả thi về mặt kỹ thuật và chứng minh tính tài chính.
	Cho đến này, mọi thứ dường như  là đơn giản. Thật không may, quy trình xác định yêu cầu thường được thực hiện không đầy đủ. Khi sản phẩm được giao cho khách hàng, có lẽ một hai năm sau khi khách hàng ký hợp đồng, khách hàng nói với các nhà phát triển, "tôi viết rằng đây là những gì tôi yêu cầu, nhưng nó thực sự  không phải những gì tôi muốn". Những gì khách hàng yêu cầu, những gì phát triển nghĩ rằng khách hàng muốn, không phải là những gì khách hàng thực sự cần thiết. Có thể có một số lý do cho tình huống khó khăn này. Đầu tiên, khách hàng có thể không thực sự hiểu những gì đang diễn ra trong tổ chức của mình. VD: không hữu ích nếu yêu cầu nhà phát triền phát triển phần mềm cho hệ điều hành nhanh hơn nếu nguyên nhân chạy chậm là do 1 cơ sở dữ liệu được thiết kế kém. Hoặc, nếu khách hàng vận hành một chuỗi các cửa hàng bán lẻ không có lợi nhuận, khách hàng có thể yêu cầu hệ thống thông tin quản lý tài chính, phản ảnh các mặt hàng đó như bán hàng, tiền lương, tài khoản phải trả và các khoản phải thu. Một sản phẩm như vậy không hữu ích nếu lý do thực sự cho các tổn thất là sự thất thoát (nhân viên, ng khác trộm cắp). Trong trường hợp đó, thì cần một hệ thống quản lý kho chứ không phải là một hệ thống thông tin.
	Nhưng lý do chính khiến khách hàng thường xuyên yêu cầu sản phẩm không đúng là do phần mềm quá phức tạp. Nếu một chuyên gia phần mềm khó hình dung một phần mềm và chức năng của nó, thì vấn đề còn tồi tệ hơn nhiều đối với một khách hàng hầu như không biết gì về máy tính.
		
4. Luồng công việc phân tích
	Mục tiêu của luồng công việc phân tích là phân tích và làm mịn các yêu cầu để đạt được sự hiểu biết chi tiết về các yêu cầu cần thiết để phát triển một sản phẩm phần mềm một cách chính xác và bảo trì một cách dễ dàng. Tuy nhiên, ngay từ đầu, không cần có quá trình phân tích. Thay vào đó, một cách có vẻ đơn giản hơn để tiến hành phát triển sản phẩm phần mềm bằng cách tiếp tục lặp đi lặp lại luồng công việc xác định yêu cầu cho đến khi có được sự hiểu biết cần thiết về sản phẩm phần mềm mục tiêu.
	
	Điểm mấu chốt là đầu ra của luồng công việc xác định yêu cầu phải được khách hàng hiểu toàn bộ. Nói cách khác, các thành phần của luồng công việc xác định yêu cầu phải được thể hiện bằng ngôn ngữ của khác hàng, tức là bằng ngôn ngữ tự nhiên. Nhưng tất cả các ngôn ngữ tự nhiên, không có ngoại lệ, có phần không chính xác và dễ gây hiểu lầm.
	
	Sự mơ hồ thuộc loại này không thể nảy sinh nếu các yêu cầu được thể hiện trong 1 ký hiệu toán học. Tuy nhiên, nếu một ký hiệu toán học được sử dụng cho các yêu cầu, thì khách hàng khó có thể hiểu được nhiều yêu cầu. Do đó, có thể có thông tin sai lệch giữa khách hàng và nhà phát triển về các yêu cầu, và do đó, sản phẩm phần mềm được phát triền để đáp ứng những yêu cầu đó có thể không phải là những gì khách hàng cần.
	
	Giải pháp là có hai luồng công việc riêng biệt. Luồng công việc xác định yêu cầu được soạn thảo bằng ngôn ngữ của khách hàng; luồng công việc phân tích soạn thảo bằng một ngôn ngữ chính xác hơn để đảm bảo rằng luồng công việc thiết kế và thực hiện được thực hiện một cách chính xác. Ngoài ra, các chi tiết khác được thêm vào trong luồng công việc phân tích, các chi tiết không liên quan đến sự hiểu biết của khách hàng về sản phẩm phần mềm mục tiêu nhưng cần thiết cho các chuyên gia phần mềm, những người sẽ phát triển sản phẩm phần mềm. Ví dụ: trạng thái ban đầu của một statechart (Mục 13.6) chắc chắn sẽ không liên quan đến khách hàng theo bất kỳ cách nào nhưng phải được đưa vào các trích dẫn cụ thể nếu các nhà phát triển muốn xây dựng sản phẩm mục tiêu một cách chính xác.
	
	Các đặc tả của sản phẩm tạo thành một hợp đồng. Các nhà phát triển phần mềm được coi là đã hoàn thành hợp đồng khi họ cung cấp một sản phẩm đáp ứng các tiêu chí đúng với bản đặc tả. Vì lý do này, các đặc tả không được bao gồm các thuật ngữ không chính xác như phù hợp, thuận tiện, đủ hoặc đủ hoặc các thuật ngữ tương tự nghe có vẻ chính xác nhưng trên thực tế không chính xác như nhau, chẳng hạn như tối ưu hoặc hoàn thành 98 phần trăm. Trong khi việc phát triển phần mềm theo hợp đồng có thể dẫn đến một vụ kiện, thì sẽ không có cơ hội để các đặc tả tạo cơ sở cho hành động pháp lý khi khách hàng và nhà phát triển thuộc cùng một tổ chức. Tuy nhiên, ngay cả trong trường hợp phát triển phần mềm nội bộ, các đặc tả luôn phải được viết như thể chúng sẽ được sử dụng làm bằng chứng trong một cuộc thử nghiệm.
	
	Khi Unified Process được sử dụng, không có tài liệu đặc tả nào theo nghĩa thông thường của thuật ngữ này. Thay vào đó, một tập hợp các thành phần UML được hiển thị cho máy khách, như được mô tả trong Chương 13. Các sơ đồ UML này và các mô tả của chúng có thể loại bỏ nhiều (nhưng không phải là tất cả) các vấn đề của tài liệu đặc tả cổ điển.
	
	Một sai lầm có thể được thực hiện bởi một nhóm phân tích cổ điển là các đặc tả không rõ ràng; như đã giải thích trước đây, sự mơ hồ là bản chất của các ngôn ngữ tự nhiên. Tính không đầy đủ là một vấn đề khác trong các đặc tả; nghĩa là, một số dữ kiện hoặc yêu cầu có liên quan có thể bị bỏ qua. Ví dụ, tài liệu đặc tả có thể không nêu rõ những hành động nào sẽ được thực hiện nếu dữ liệu đầu vào có lỗi. Hơn nữa, tài liệu đặc tả có thể chứa đựng những mâu thuẫn. Ví dụ, một vị trí trong tài liệu đặc tả cho một sản phẩm kiểm soát quá trình lên men quy định rằng nếu áp suất vượt quá 35 psi, thì van M17 phải được đóng ngay lập tức. Tuy nhiên, một nơi khác cho rằng, nếu áp suất vượt quá 35 psi thì phải báo ngay cho người vận hành; chỉ khi người vận hành không có biện pháp khắc phục trong vòng 30 giây thì van M17 mới được tự động đóng lại. Việc phát triển phần mềm không thể tiến hành cho đến khi các vấn đề như vậy trong các đặc tả đã được khắc phục. Như đã chỉ ra trong đoạn trước, nhiều vấn đề này có thể được giảm bớt bằng cách sử dụng Unified Process. Điều này là do các sơ đồ UML cùng với các mô tả của các sơ đồ đó ít có khả năng chứa sự mơ hồ, không đầy đủ và mâu thuẫn.
	
	Sau khi khách hàng đã phê duyệt các đặc tả, kế hoạch chi tiết và ước tính sẽ bắt đầu. Không một khách hàng nào ủy quyền cho một dự án phần mềm mà không biết trước dự án sẽ kéo dài bao lâu và chi phí là bao nhiêu. Theo quan điểm của các nhà phát triển, hai hạng mục này đều quan trọng như nhau. Nếu các nhà phát triển đánh giá thấp chi phí của một dự án, thì khách hàng sẽ trả phí theo thỏa thuận, có thể ít hơn đáng kể so với chi phí thực tế của nhà phát triển. Ngược lại, nếu các nhà phát triển ước tính quá cao chi phí của dự án, thì khách hàng có thể từ chối dự án hoặc giao việc cho các nhà phát triển khác có ước tính hợp lý hơn. Các vấn đề tương tự cũng nảy sinh liên quan đến ước tính thời lượng. Nếu các nhà phát triển đánh giá thấp thời gian hoàn thành một dự án, thì tốt nhất, việc giao sản phẩm trễ sẽ khiến khách hàng mất lòng tin. Tệ nhất, các điều khoản phạt chậm trễ trong hợp đồng được viện dẫn, khiến các nhà phát triển bị thiệt hại về mặt tài chính. Một lần nữa, nếu các nhà phát triển đánh giá quá cao thời gian để sản phẩm được giao, khách hàng có thể trao công việc cho những nhà phát triển hứa hẹn giao hàng nhanh hơn.
	
	Đối với các nhà phát triển, chỉ ước tính thời lượng và tổng chi phí là không đủ. Các nhà phát triển cần chỉ định nhân sự thích hợp cho các quy trình công việc khác nhau của quá trình phát triển. Ví dụ: nhóm thực hiện không thể bắt đầu cho đến khi các thành phần thiết kế liên quan đã được nhóm đảm bảo chất lượng phần mềm (SQA) phê duyệt và nhóm thiết kế không cần thiết cho đến khi nhóm phân tích đã hoàn thành nhiệm vụ của mình. Nói cách khác, các nhà phát triển phải lên kế hoạch trước. Kế hoạch quản lý dự án phần mềm (SPMP) phải được lập ra nhằm đưa ra các quy trình công việc riêng biệt của quá trình phát triển và chỉ ra những thành viên nào của tổ chức phát triển tham gia vào từng nhiệm vụ, cũng như thời hạn hoàn thành từng nhiệm vụ.
	
	Một kế hoạch chi tiết có thể được lập nhanh chóng sau khi các đặc tả đã được hoàn thiện. Trước thời điểm đó, dự án quá vô định hình để hoàn thành lập kế hoạch . Một số khía cạnh của dự án chắc chắn phải được lên kế hoạch ngay từ đầu, nhưng cho đến khi các nhà phát triển biết chính xác những gì sẽ được xây dựng, họ không thể chỉ rõ tất cả các khía cạnh của kế hoạch xây dựng nó. Do đó, khi các đặc tả đã được khách hàng chấp thuận, việc chuẩn bị kế hoạch quản lý dự án phần mềm sẽ bắt đầu. Các thành phần chính của kế hoạch là deliverables(những gì khách hàng sẽ nhận được), milestones(khi khách hàng nhận được chúng) và budget(chi phí sẽ là bao nhiêu).
	
	Kế hoạch mô tả chi tiết đầy đủ nhất về tiến trình phần mềm. Nó bao gồm các khía cạnh như mô hình vòng đời sẽ được sử dụng, cơ cấu tổ chức của tổ chức phát triển, trách nhiệm của dự án, các mục tiêu và ưu tiên của người quản lý, các kỹ thuật và công cụ CASE sẽ được sử dụng, lịch trình chi tiết, ngân sách và phân bổ nguồn lực. Bên dưới toàn bộ kế hoạch là thời gian và ước tính chi phí; các kỹ thuật để có được các ước tính như vậy được mô tả trong Phần 9.2.
	Luồng công việc phân tích được mô tả trong Chương 12 và 13: các kỹ thuật phân tích cổ điển được mô tả trong Chương 12 và phân tích hướng đối tượng là chủ đề của Chương 13. Một artifact chính của luồng công việc phân tích là kế hoạch quản lý dự án phần mềm. Giải thích về cách tạo SPMP được đưa ra trong Phần 9.3 và 9.5.


5. Luồng công việc thiết kế
	Các đặc tả của một sản phẩm cho biết sản phẩm đó phải làm gì; thiết kế cho thấy sản phẩm sẽ làm được điều đó như thế nào. Chính xác hơn, mục tiêu của luồng công việc thiết kế là cải tiến các thành phần của luồng công việc phân tích cho đến khi tài liệu ở dạng mà các lập trình viên có thể thực hiện được.
	
	Như đã giải thích trong Phần 1.3, trong giai đoạn thiết kế cổ điển, nhóm thiết kế xác định cấu trúc bên trong của sản phẩm. Các nhà thiết kế phân tách sản phẩm thành các mô-đun - các đoạn mã độc lập với các giao diện được xác định rõ ràng với phần còn lại của sản phẩm. Giao diện của mỗi mô-đun (nghĩa là, các đối số được truyền cho mô-đun và các đối số được trả về bởi mô-đun) phải được chỉ định chi tiết. Ví dụ, một mô-đun có thể đo mực nước trong lò phản ứng hạt nhân và gây ra âm thanh báo động nếu mức quá thấp. Một mô-đun trong sản phẩm điện tử hàng không có thể lấy hai hoặc nhiều bộ tọa độ của tên lửa đối phương đang bay tới, tính toán quỹ đạo của nó và gọi một mô-đun khác để thông báo cho phi công về hành động né tránh có thể xảy ra. Khi nhóm đã hoàn thành việc phân rã thành các mô-đun (thiết kế kiến ​​trúc), thiết kế chi tiết sẽ được thực hiện. Đối với mỗi mô-đun, các thuật toán được chọn và cấu trúc dữ liệu được chọn.
	
	Bây giờ chuyển sang mô hình hướng đối tượng, cơ sở của mô hình đó là lớp(class), một loại mô-đun cụ thể. Các lớp được trích xuất trong luồng công việc phân tích và được thiết kế trong luồng công việc thiết kế. Do đó, bản đối chiếu hướng đối tượng của thiết kế kiến trúc được thực hiện như một phần của luồng công việc phân tích hướng đối tượng và bản đối chiếu hướng đối tượng của thiết kế chi tiết là một phần của luồng công việc thiết kế hướng đối tượng.
	
	Đội ngũ thiết kế phải ghi chép tỉ mỉ các quyết định thiết kế được đưa ra. Thông tin này là cần thiết vì hai lý do.
		1. Trong khi sản phẩm đang được thiết kế, đôi khi sẽ đến ngõ cụt và nhóm thiết kế phải quay lại và thiết kế lại một số phần nhất định. Có một hồ sơ bằng văn bản về lý do tại sao các quyết định cụ thể được đưa ra sẽ hỗ trợ nhóm khi điều này xảy ra và giúp nhóm trở lại đúng hướng. 
		2. Theo lý thuyết, thiết kế của sản phẩm nên có kết thúc mở, có nghĩa là các cải tiến trong tương lai (bảo trì sau giao hàng) có thể được thực hiện bằng cách thêm các lớp mới hoặc thay thế các lớp hiện có mà không ảnh hưởng đến thiết kế nói chung. Tất nhiên, trên thực tế, lý tưởng này khó đạt được. Hạn chế về thời hạn trong thế giới thực là do các nhà thiết kế phải vật lộn với đồng hồ để hoàn thành một thiết kế đáp ứng các đặc tả ban đầu mà không phải lo lắng về bất kỳ cải tiến nào sau này. Nếu các cải tiến trong tương lai (sẽ được bổ sung sau khi sản phẩm được giao cho khách hàng) được bao gồm trong đặc tả, thì chúng phải được phép đưa vào thiết kế, nhưng trường hợp này là cực kỳ hiếm. Nói chung, các đặc tả và theo sau là thiết kế, chỉ đáp ứng các yêu cầu hiện tại. Ngoài ra, trong khi sản phẩm vẫn đang được thiết kế, không có cách nào để xác định tất cả các cải tiến có thể có trong tương lai. Cuối cùng, nếu thiết kế phải tính đến tất cả các khả năng trong tương lai, thì tốt nhất là nó sẽ khó sử dụng; tệ nhất, nó sẽ phức tạp đến mức không thể thực hiện được. Vì vậy các nhà thiết kế phải thỏa hiệp, đưa ra một thiết kế có thể mở rộng theo nhiều cách hợp lý mà không cần thiết kế lại toàn bộ. Nhưng, trong một sản phẩm trải qua quá trình cải tiến lớn, sẽ đến lúc thiết kế đơn giản là không thể xử lý các thay đổi tiếp theo. Khi đạt đến giai đoạn này, sản phẩm phải được thiết kế lại toàn bộ. Nhiệm vụ của nhóm thiết kế lại dễ dàng hơn đáng kể nếu các thành viên trong nhóm được cung cấp hồ sơ về lý do của tất cả các quyết định thiết kế ban đầu.
	

6. Luồng công việc cài đặt
	Mục tiêu của luồng công việc cài đặt là cài đặt sản phẩm phần mềm mục tiêu bằng (các)ngôn ngữ  cài đặt đã chọn. Một sản phẩm phần mềm nhỏ đôi khi được thực hiện bởi nhà thiết kế. Ngược lại, một sản phẩm phần mềm lớn được phân chia thành các hệ thống con nhỏ hơn, sau đó được thực hiện song song bởi các nhóm code. Các hệ thống con lại bao gồm các components or code artifacts được thực hiện bởi một lập trình viên riêng lẻ.
	
	Thông thường, tài liệu duy nhất được cung cấp cho một lập trình viên là về thành phần thiết kế có liên quan. Ví dụ, trong trường hợp mô hình cổ điển, lập trình viên được cung cấp thiết kế chi tiết của mô-đun mà họ sẽ thực hiện. Thiết kế chi tiết thường cung cấp đủ thông tin để lập trình viên thực hiện code artifact mà không gặp quá nhiều khó khăn. Nếu có bất kỳ vấn đề nào, chúng có thể nhanh chóng được giải quyết bằng cách tham khảo ý kiến ​​của nhà thiết kế có trách nhiệm. Tuy nhiên, không có cách nào để lập trình viên cá nhân biết được thiết kế kiến ​​trúc có đúng hay không. Chỉ khi tích hợp các code artifact riêng lẻ bắt đầu thì những thiếu sót của thiết kế mới bắt đầu được chỉ ra.
	
	Giả sử rằng một số code artifact đã được triển khai, tích hợp và các phần của sản phẩm đã được tích hợp cho đến nay dường như đang hoạt động bình thường. Giả sử thêm rằng một lập trình viên đã triển khai chính xác artifact a45, nhưng khi artifact này được tích hợp với các artifact hiện có khác, sản phẩm không thành công. Nguyên nhân của sự thất bại không nằm ở bản thân artifact a45, mà là ở cách artifact a45 tương tác với phần còn lại của sản phẩm, như đặc điểm trong thiết kế kiến ​​trúc. Tuy nhiên, trong loại tình huống này, lập trình viên vừa tạo artifact a45 có xu hướng bị đổ lỗi rằng gây ra lỗi. Điều này là không may, bởi vì lập trình viên đã đơn giản làm theo các hướng dẫn do nhà thiết kế cung cấp và thực hiện artifact chính xác như mô tả trong thiết kế chi tiết cho artifact đó. Các thành viên của nhóm lập trình hiếm khi được xem “bức tranh lớn”, tức là thiết kế kiến ​​trúc, chưa nói đến việc được yêu cầu bình luận về nó. Mặc dù thật không công bằng khi mong đợi một lập trình viên cá nhân nhận thức được tác động của một artifact cụ thể đối với toàn bộ sản phẩm, nhưng điều này không may lại xảy ra trong thực tế quá thường xuyên. Đây là một lý do khác tại sao nó rất quan trọng đối với việc thiết kế phải đúng ở mọi khía cạnh.
	
	Tính đúng đắn của thiết kế (cũng như các hiện vật khác) được kiểm tra như một phần của luồng công việc kiểm thử.

7. Luồng công việc kiểm thử
	Như trong Hình 2.4, trong Unified Process, việc kiểm thử được thực hiện song song với các luồng công việc khác, bắt đầu từ đầu. Có hai khía cạnh chính để kiểm tra.
	1. Mỗi nhà phát triển và nhà bảo trì phải chịu trách nhiệm cá nhân đảm bảo rằng công việc của họ là chính xác. Do đó, một chuyên gia phần mềm phải kiểm tra và thử nghiệm lại từng artifact mà họ phát triển hoặc duy trì.
	2. Sau khi chuyên gia phần mềm tin rằng một artifact là đúng, nó sẽ được chuyển giao cho nhóm đảm bảo chất lượng phần mềm để kiểm tra độc lập
	
	Bản chất của luồng công việc kiểm thử thay đổi tùy thuộc vào các artifact được kiểm tra. Tuy nhiên, một đặc điểm quan trọng đối với tất cả các artifact là traceability.
	
7.1. Requirements Artifact
	Nếu các requirements artifact có thể kiểm tra được trong vòng đời của sản phẩm phần mềm, thì một đặc tính mà chúng phải có là khả năng truy xuất nguồn gốc(traceability). Ví dụ, phải có khả năng truy tìm mọi mục trong analysis artifact trở lại requirements artifact và tương tự đối với design artifact và implementation artifact. Nếu các yêu cầu đã được trình bày một cách có phương pháp, được đánh số hợp lý, được tham chiếu chéo và được lập chỉ mục, thì các nhà phát triển sẽ gặp ít khó khăn trong việc truy tìm các artifact tiếp theo và đảm bảo rằng chúng thực sự phản ánh đúng các yêu cầu của khách hàng. Khi công việc của các thành viên trong nhóm yêu cầu sau đó được nhóm SQA kiểm tra, việc xác định nguồn gốc cũng sẽ đơn giản hóa nhiệm vụ của họ.
	
7.2. Analysis Artifacts 
	Như đã chỉ ra trong Chương 1, một nguồn lỗi chính trong phần mềm được phân phối là các lỗi trong đặc tả không được phát hiện cho đến khi phần mềm được cài đặt trên máy tính của khách hàng và được tổ chức của khách hàng sử dụng cho mục đích đã định. Do đó, cả nhóm phân tích và nhóm SQA đều phải kiểm tra các analysis artifact một cách tận tình. Ngoài ra, họ phải đảm bảo rằng các đặc tả là khả thi, chẳng hạn như một thành phần phần cứng cụ thể đủ nhanh hoặc dung lượng lưu trữ đĩa trực tuyến hiện tại của khách hàng đủ để xử lý sản phẩm mới. Một cách tuyệt vời để kiểm tra các analysis artifact là buổi xem xét lại. Đại diện của nhóm phân tích và của khách hàng có mặt. Cuộc họp thường do một thành viên của nhóm SQA chủ trì. Mục đích của việc xem xét là để xác định xem các analysis artifact có chính xác hay không. Người đánh giá xem qua các analysis artifact, kiểm tra xem có bất kỳ lỗi nào không. Hướng dẫn(Walkthroughs) và kiểm tra(inspections) là hai loại đánh giá và chúng được mô tả trong Phần 6.2.
	
	Bây giờ chúng ta chuyển sang việc kiểm tra lập kế hoạch chi tiết và ước tính diễn ra sau khi khách hàng đã ký vào các đặc tả. Trong khi điều quan trọng là mọi khía cạnh của SPMP phải được kiểm tra tỉ mỉ bởi nhóm phát triển và sau đó là nhóm SQA, đặc biệt phải chú ý đến thời lượng và ước tính chi phí của kế hoạch. Một cách để làm điều này là ban giám đốc có được hai (hoặc nhiều) ước tính độc lập về cả thời gian và chi phí khi bắt đầu lập kế hoạch chi tiết, sau đó điều chỉnh bất kỳ sự khác biệt đáng kể nào. Đối với tài liệu SPMP, một cách tuyệt vời để kiểm tra nó là xem xét tương tự như xem xét các analysis artifact. Nếu thời gian và ước tính chi phí đạt yêu cầu, khách hàng sẽ cho phép dự án tiếp tục.
	
7.3. Design Artifacts
	Như đã đề cập trong Phần 3.7.1, một khía cạnh quan trọng của khả năng kiểm tra là khả năng xác định nguồn gốc. Trong trường hợp của thiết kế, điều này có nghĩa là mọi phần của thiết kế có thể được liên kết với một artifact phân tích. Một thiết kế tham chiếu chéo phù hợp cung cấp cho các nhà phát triển và nhóm SQA một công cụ mạnh mẽ để kiểm tra xem thiết kế có đồng ý với các đặc tả hay không và liệu mọi phần của đặc tả có được hoàn thiện trong một số phần của thiết kế hay không.
	
	Buổi xem xét lại thiết kế tương tự như  xem xét lại mà các đặc tả trải qua. Tuy nhiên, xét về bản chất kỹ thuật của hầu hết các thiết kế, khách hàng thường không có mặt. Các thành viên của nhóm thiết kế và nhóm SQA làm việc thông qua toàn bộ thiết kế cũng như thông qua từng design artifact riêng biệt, đảm bảo rằng thiết kế là chính xác. Các loại lỗi cần tìm bao gồm lỗi logic, lỗi giao diện, thiếu xử lý ngoại lệ (xử lý điều kiện lỗi) và quan trọng nhất là không phù hợp với các đặc tả. Ngoài ra, nhóm đánh giá luôn phải nhận thức được khả năng một số lỗi phân tích không được phát hiện trong quy trình làm việc trước đó. Mô tả chi tiết về quá trình xem xét được đưa ra trong Phần 6.2

7.4. Implementation Artifacts
	Mỗi thành phần nên được kiểm tra trong khi nó đang được triển khai (desk checking); và sau khi nó đã được triển khai, nó sẽ được chạy trên các test case. Việc kiểm tra không chính thức này được thực hiện bởi lập trình viên. Sau đó, nhóm đảm bảo chất lượng kiểm tra từng thành phần một cách phương pháp; đây được gọi là unit test. Một loạt các kỹ thuật kiểm thử đơn vị được mô tả trong Chương 15.
	
	Ngoài việc chạy các test case, xem xét lại code là một kỹ thuật thành công, mạnh mẽ để phát hiện lỗi lập trình. Ở đây, lập trình viên hướng dẫn các thành viên của nhóm đánh giá thông qua việc liệt kê thành phần. Nhóm đánh giá phải bao gồm một đại diện của SQA. Quy trình tương tự như xem xét các đặc tả và thiết kế được mô tả trước đây. Như trong tất cả các quy trình công việc khác, hồ sơ về các hoạt động của nhóm SQA được lưu giữ như một phần của luồng công công việc thử nghiệm.
	
	Khi một thành phần đã được code, nó phải được kết hợp với các thành phần được code khác để nhóm SQA có thể xác định xem sản phẩm (một phần) nói chung có hoạt động chính xác hay không. Cách mà các thành phần được tích hợp (tất cả cùng một lúc hoặc một lúc) và thứ tự cụ thể (từ trên xuống dưới hoặc từ dưới lên trên trong sơ đồ kết nối thành phần hoặc hệ thống phân cấp lớp) có thể có ảnh hưởng quan trọng đến chất lượng của sản phẩm kết quả. Ví dụ: giả sử sản phẩm được tích hợp từ dưới lên. Một lỗi thiết kế lớn, nếu có, sẽ xuất hiện muộn, đòi hỏi phải thực hiện lại một cách tốn kém. Ngược lại, nếu các thành phần được tích hợp từ trên xuống, thì các thành phần cấp thấp hơn thường không được kiểm tra kỹ lưỡng như trường hợp sản phẩm được tích hợp từ dưới lên. Những vấn đề này và các vấn đề khác được thảo luận chi tiết trong Chương 15. Ở đó có giải thích chi tiết về lý do tại sao mã hóa và tích hợp phải được thực hiện song song.
	
	Mục đích của thử nghiệm tích hợp(integration testing) này là để kiểm tra xem các thành phần kết hợp với nhau một cách chính xác để đạt được một sản phẩm đáp ứng các đặc tả của nó. Trong quá trình kiểm tra tích hợp, phải đặc biệt chú ý đến việc kiểm tra các giao diện thành phần. Điều quan trọng là số lượng, thứ tự và loại đối số chính thức phải khớp với số lượng, thứ tự và loại đối số thực tế. Việc kiểm tra kiểu mạnh này [van Wijngaarden et al., 1975] được trình biên dịch và trình liên kết thực hiện tốt nhất. Tuy nhiên, nhiều ngôn ngữ không được gõ mạnh. Khi một ngôn ngữ như vậy được sử dụng, các thành viên của nhóm SQA phải kiểm tra các giao diện.
	
	Khi kiểm tra tích hợp đã hoàn thành (nghĩa là khi tất cả các thành phần đã được mã hóa và tích hợp), nhóm SQA thực hiện kiểm tra sản phẩm. Toàn bộ chức năng của sản phẩm được kiểm tra dựa trên các đặc tả. Đặc biệt, các ràng buộc được liệt kê trong đặc tả phải được thử nghiệm. Ví dụ điển hình là thời gian phản hồi có được đáp ứng hay không. Bởi vì mục đích của kiểm tra sản phẩm là để xác định xem các đặc tả đã được thực hiện chính xác hay chưa, nhiều trường hợp kiểm thử có thể được đưa ra sau khi các đặc tả hoàn chỉnh.
	
	Không chỉ phải kiểm tra tính đúng đắn của sản phẩm mà còn phải kiểm tra độ bền của sản phẩm. Tức là, dữ liệu đầu vào có lỗi cố ý được gửi để xác định xem sản phẩm có bị lỗi hay không hoặc liệu khả năng xử lý lỗi của nó có đủ để xử lý dữ liệu xấu hay không. Nếu sản phẩm sẽ được chạy cùng với phần mềm hiện được cài đặt của khách hàng, thì các thử nghiệm cũng phải được thực hiện để kiểm tra xem sản phẩm mới sẽ không có ảnh hưởng xấu đến hoạt động máy tính hiện có của khách hàng. Cuối cùng, phải kiểm tra xem mã nguồn và tất cả các loại tài liệu khác có đầy đủ và nhất quán nội bộ hay không. Thử nghiệm sản phẩm được thảo luận trong Phần 15.21. Trên cơ sở kết quả của việc kiểm tra sản phẩm, một nhà quản lý cấp cao trong tổ chức phát triển sẽ quyết định xem sản phẩm đã sẵn sàng để phát hành cho khách hàng hay chưa.
	
	Bước cuối cùng trong việc kiểm tra các artifact triển khai là kiểm tra chấp nhận(acceptance testing). Phần mềm được giao cho khách hàng, người kiểm tra nó trên phần cứng thực tế, sử dụng dữ liệu thực tế trái ngược với dữ liệu thử nghiệm. Bất kể nhóm phát triển hoặc nhóm SQA có phương pháp như thế nào, vẫn có sự khác biệt đáng kể giữa các test case, về bản chất của chúng là dữ liệu nhân tạo và dữ liệu thực tế. Một sản phẩm phần mềm không thể được coi là đáp ứng các đặc tả của nó cho đến khi sản phẩm đã vượt qua kiểm tra chấp nhận. Thông tin chi tiết về thử nghiệm chấp nhận được nêu trong Phần 15.22.
	
	Trong trường hợp phần mềm COTS (Phần 1.11), ngay sau khi quá trình thử nghiệm sản phẩm hoàn tất, các phiên bản của sản phẩm hoàn chỉnh sẽ được cung cấp cho một số khách hàng có thể có trong tương lai để thử nghiệm tại chỗ. Phiên bản đầu tiên như vậy được gọi là bản phát hành alpha. Bản phát hành alpha đã hiệu chỉnh được gọi là bản phát hành beta; nói chung, bản phát hành beta dự định gần với phiên bản cuối cùng. (Các điều khoản phát hành alpha và phát hành beta thường được áp dụng cho tất cả các loại sản phẩm phần mềm, không chỉ COTS.)
	
	Các lỗi trong phần mềm COTS thường dẫn đến việc bán sản phẩm kém và tổn thất lớn cho công ty phát triển. Vì vậy, Lỗi phải được chỉ ra sớm nhất có thể, các nhà phát triển phần mềm COTS thường cung cấp bản phát hành alpha hoặc beta cho các công ty được chọn, với hy vọng rằng các thử nghiệm tại chỗ sẽ phát hiện ra bất kỳ lỗi tiềm ẩn nào. Đổi lại, các trang web alpha và beta thường được hứa hẹn là các bản sao miễn phí của phiên bản phần mềm được phân phối. Rủi ro liên quan đến một công ty tham gia thử nghiệm alpha hoặc beta. Đặc biệt, các bản phát hành alpha có thể bị lỗi, dẫn đến thất vọng, lãng phí thời gian và có thể làm hỏng cơ sở dữ liệu. Tuy nhiên, công ty đã có bước khởi đầu trong việc sử dụng phần mềm COTS mới, phần mềm có thể mang lại lợi thế hơn so với các đối thủ cạnh tranh. Đôi khi xảy ra sự cố khi các tổ chức phần mềm sử dụng thử nghiệm alpha của khách hàng tiềm năng thay vì thử nghiệm sản phẩm kỹ lưỡng của nhóm SQA. Mặc dù thử nghiệm alpha tại một số địa điểm khác nhau thường đưa ra nhiều lỗi, nhưng không có gì thay thế cho thử nghiệm phương pháp mà nhóm SQA có thể cung cấp.
	
8. Bảo trì sau giao hàng
	Bảo trì sau giao hàng không phải là hoạt động được thực hiện một cách miễn cưỡng sau khi sản phẩm đã được phân phối và cài đặt trên máy tính của khách hàng. Ngược lại, nó là một phần không thể thiếu của tiến trình phần mềm phải được lập kế hoạch ngay từ đầu. Như đã giải thích trong Phần 3.5, thiết kế, trong chừng mực khả thi, nên tính đến các cải tiến trong tương lai. Lập trình phải được thực hiện với lưu ý bảo trì trong tương lai. Xét cho cùng, như đã chỉ ra trong Phần 1.3, chi phí bảo trì sau giao hàng nhiều hơn so với tất cả các hoạt động phần mềm khác cộng lại. Do đó, nó là một khía cạnh quan trọng của sản xuất phần mềm. Bảo trì sau giao hàng không bao giờ được coi là một việc nên làm. Thay vào đó, toàn bộ nỗ lực phát triển phần mềm phải được thực hiện theo cách để giảm thiểu tác động của việc bảo trì sau giao hàng không thể tránh khỏi trong tương lai.
	
	Một vấn đề phổ biến với bảo trì sau giao hàng là thiếu tài liệu. Trong quá trình phát triển phần mềm theo thời hạn, các artifact phân tích và thiết kế ban đầu thường không được cập nhật và do đó, gần như vô dụng đối với nhóm bảo trì. Các tài liệu khác như sổ tay cơ sở dữ liệu hoặc hướng dẫn vận hành có thể không bao giờ được viết, bởi vì ban quản lý quyết định rằng việc giao sản phẩm cho khách hàng đúng hạn quan trọng hơn việc phát triển tài liệu song song với phần mềm. Trong nhiều trường hợp, mã nguồn là tài liệu duy nhất có sẵn cho người bảo trì. Tỷ lệ luân chuyển nhân sự cao trong ngành công nghiệp phần mềm làm trầm trọng thêm tình hình bảo trì, trong đó không có nhà phát triển ban đầu nào có thể làm việc cho tổ chức vào thời điểm bảo trì được thực hiện. Bảo trì sau giao hàng thường xuyên là khía cạnh thách thức nhất của sản xuất phần mềm vì những lý do này và những lý do bổ sung được đưa ra trong Chương 16.
	
	Bây giờ chuyển sang kiểm tra, có hai khía cạnh để kiểm tra các thay đổi được thực hiện đối với sản phẩm khi thực hiện bảo trì sau giao hàng. Đầu tiên là kiểm tra xem các thay đổi bắt buộc đã được thực hiện đúng chưa. Khía cạnh thứ hai là đảm bảo rằng, trong quá trình thực hiện các thay đổi bắt buộc đối với sản phẩm, không có thay đổi vô ý nào khác được thực hiện. Do đó, một khi lập trình viên xác định rằng các thay đổi mong muốn đã được thực hiện, sản phẩm phải được kiểm tra dựa trên các trường hợp kiểm tra trước đó để đảm bảo rằng chức năng của phần còn lại của sản phẩm không bị ảnh hưởng. Thủ tục này được gọi là kiểm tra hồi quy(regression testing). Để hỗ trợ kiểm thử hồi quy, cần phải giữ lại tất cả các test case trước đó, cùng với kết quả chạy các test case đó. Kiểm tra trong quá trình bảo trì sau giao hàng được thảo luận chi tiết hơn trong Chương 16.
	
	Một khía cạnh chính của bảo trì sau phân phối là ghi lại tất cả các thay đổi đã thực hiện, cùng với lý do của mỗi thay đổi. Khi phần mềm được thay đổi, nó phải được kiểm tra hồi quy. Do đó, các trường hợp kiểm thử hồi quy là một dạng tài liệu trung tâm.

9. Retirement
	Giai đoạn cuối cùng trong vòng đời của phần mềm là dừng sử dụng. Sau nhiều năm phục vụ, sẽ đến giai đoạn khi việc bảo trì thêm sau giao hàng không còn hiệu quả về chi phí nữa.
	• Đôi khi những thay đổi được đề xuất quá lớn đến mức phải thay đổi toàn bộ thiết kế. Trong trường hợp như vậy, việc thiết kế lại và mã hóa lại toàn bộ sản phẩm sẽ ít tốn kém hơn.
	• Nhiều thay đổi có thể đã được thực hiện đối với thiết kế ban đầu mà sự phụ thuộc lẫn nhau đã vô tình được tích hợp vào sản phẩm và ngay cả một thay đổi nhỏ đối với một thành phần nhỏ cũng có thể có ảnh hưởng mạnh mẽ đến chức năng của toàn bộ sản phẩm.
	• Tài liệu có thể không được duy trì đầy đủ, do đó làm tăng nguy cơ xảy ra lỗi hồi quy đến mức sẽ an toàn hơn khi mã hóa lại hơn là duy trì.
	• Phần cứng (và hệ điều hành) mà sản phẩm chạy phải được thay thế; có thể tiết kiệm hơn nếu thực hiện lại từ đầu hơn là sửa đổi.
	
	Trong mỗi trường hợp này, phiên bản hiện tại được thay thế bằng phiên bản mới và quá trình phần mềm tiếp tục.
	Mặt khác, việc dừng sử dụng thực sự là một sự kiện hơi hiếm xảy ra khi một sản phẩm đã phát triển hơn tính hữu dụng của nó. Tổ chức khách hàng không còn yêu cầu chức năng được cung cấp bởi sản phẩm và nó sẽ bị xóa khỏi máy tính.
	
10. Các pha của Unified Process
	Mặc dù về lý thuyết, việc phát triển một sản phẩm phần mềm có thể được thực hiện với bất kỳ số lượng gia tăng nào, nhưng việc phát triển trong thực tế dường như bao gồm bốn bước gia tăng. Các phần gia tăng hoặc các giai đoạn được mô tả trong Phần 3.10.1 đến 3.10.4, cùng với các sản phẩm của mỗi giai đoạn, tức là các phần artifact sẽ được hoàn thành vào cuối giai đoạn đó.
	
	Mỗi bước được thực hiện trong Unified Process thuộc một trong năm luồng công việc cốt lõi và cũng thuộc một trong bốn giai đoạn, giai đoạn khởi đầu, giai đoạn sửa tỉ mỉ, giai đoạn xây dựng và giai đoạn chuyển tiếp. Các bước khác nhau của bốn giai đoạn này đã được mô tả trong Phần 3.3 đến 3.7. Ví dụ, xây dựng một tình huống nghiệp vụ(business case) là một phần của luồng công việc xác định yêu cầu (Phần 3.3). Nó cũng là một phần của giai đoạn khởi đầu. Tuy nhiên, mỗi bước phải được xem xét hai lần, như sẽ được giải thích.
	
	Xem xét luồng công việc xác định yêu cầu. Để xác định nhu cầu của khách hàng, một trong các bước, như vừa nêu, là xây dựng một tình huống nghiệp vụ. Nói cách khác, trong khuôn khổ của luồng công việc xác định yêu cầu, việc xây dựng một tình huống nghiệp vụ được trình bày trong bối cảnh kỹ thuật. Trong Phần 3.10.1, mô tả được trình bày về việc xây dựng một trường hợp nghiệp vụ trong khuôn khổ của giai đoạn khởi đầu, giai đoạn mà ban quản lý quyết định có phát triển sản phẩm phần mềm được đề xuất hay không. Có nghĩa là, việc xây dựng một tình huống nghiệp vụ được trình bày ngắn gọn trong bối cảnh kinh tế (Phần 1.2).
	
	Đồng thời, không có ích lợi gì khi trình bày mỗi bước hai lần, cả hai lần ở cùng một mức độ chi tiết. Theo đó, giai đoạn khởi đầu được mô tả chuyên sâu để làm nổi bật sự khác biệt giữa bối cảnh kỹ thuật của quy trình làm việc và bối cảnh kinh tế của các giai đoạn, nhưng ba giai đoạn khác được phác thảo đơn giản.
	
10.1. Inception phase
	Mục đích của giai đoạn khởi đầu (bước đầu tiên) là xác định xem liệu có đáng để phát triển sản phẩm phần mềm mục tiêu hay không. Nói cách khác, mục tiêu chính của giai đoạn này là xác định xem sản phẩm phần mềm được đề xuất có khả thi về mặt kinh tế hay không.
	
	Hai bước của quy trình yêu cầu là hiểu lĩnh vực và xây dựng mô hình nghiệp vụ. Rõ ràng, không có cách nào để các nhà phát triển có thể đưa ra bất kỳ loại ý kiến ​​nào về một sản phẩm phần mềm có thể có trong tương lai trừ khi họ hiểu rõ lĩnh vực mà họ đang xem xét phát triển sản phẩm phần mềm mục tiêu trước. Không thành vấn đề nếu lĩnh vực là mạng truyền hình, công ty máy công cụ hay bệnh viện chuyên về bệnh gan — nếu các nhà phát triển không hiểu đầy đủ về miền, thì có thể ít phụ thuộc vào những gì họ xây dựng sau đó. Do đó, bước đầu tiên là có được kiến ​​thức về lĩnh vực đó. Sau khi các nhà phát triển đã hiểu đầy đủ về lĩnh vực đó, bước thứ hai là xây dựng mô hình nghiệp vụ, tức là mô tả các quy trình kinh doanh của khách hàng. Nói cách khác, yêu cầu đầu tiên là hiểu bản thân lĩnh vực và yêu cầu thứ hai là hiểu chính xác cách tổ chức của khách hàng hoạt động trong lĩnh vực đó.
	
	Bây giờ phạm vi của dự án mục tiêu phải được phân định. Ví dụ: hãy xem xét một sản phẩm phần mềm được đề xuất cho một mạng ATM mới có độ bảo mật cao cho một chuỗi ngân hàng trên toàn quốc. Quy mô của mô hình kinh doanh của toàn bộ chuỗi ngân hàng có thể là rất lớn. Để xác định sản phẩm phần mềm mục tiêu nên kết hợp những gì, các nhà phát triển phải chỉ tập trung vào một tập hợp con của mô hình kinh doanh, cụ thể là tập hợp con được bao phủ bởi sản phẩm phần mềm được đề xuất. Do đó, phân định phạm vi của dự án đề xuất là bước thứ ba.
	
	Bây giờ các nhà phát triển có thể bắt đầu thực hiện tình huống nghiệp vụ ban đầu. Các câu hỏi cần được trả lời trước khi tiến hành dự án bao gồm [Jacobson, Booch, và Rumbaugh, 1999]:
	• Sản phẩm phần mềm được đề xuất có hiệu quả về chi phí không? Nghĩa là, liệu những lợi ích thu được do phát triển sản phẩm phần mềm có lớn hơn chi phí liên quan không? Mất bao lâu để thu được lợi tức từ khoản đầu tư cần thiết để phát triển sản phẩm phần mềm được đề xuất? Ngoài ra, khách hàng sẽ phải trả chi phí gì nếu họ quyết định không phát triển sản phẩm phần mềm được đề xuất? Nếu sản phẩm phần mềm được bán trên thị trường, các nghiên cứu tiếp thị cần thiết đã được thực hiện chưa?
	• Sản phẩm phần mềm được đề xuất có thể được giao trong thời gian không? Nghĩa là, nếu sản phẩm phần mềm được đưa ra thị trường muộn, liệu tổ chức có thu được lợi nhuận không hay một sản phẩm phần mềm cạnh tranh sẽ chiếm được thị phần của con sư tử? Ngoài ra, nếu sản phẩm phần mềm được phát triển để hỗ trợ các hoạt động riêng của tổ chức khách hàng (có thể bao gồm các hoạt động quan trọng của sứ mệnh), thì tác động nếu sản phẩm phần mềm được đề xuất được giao muộn là gì?
	• Những rủi ro nào liên quan đến việc phát triển sản phẩm phần mềm, và làm thế nào để giảm thiểu những rủi ro này? Các thành viên trong nhóm sẽ phát triển sản phẩm phần mềm được đề xuất có kinh nghiệm cần thiết không? Phần cứng mới có cần thiết cho sản phẩm phần mềm này không và nếu có, có nguy cơ sản phẩm không được giao kịp thời không? Nếu vậy, có cách nào để giảm thiểu rủi ro đó, có lẽ bằng cách đặt hàng phần cứng dự phòng từ một nhà cung cấp khác? Có cần các công cụ phần mềm (Chương 5) không? Hiện tại chúng có sẵn không? Chúng có tất cả các chức năng cần thiết không? Có khả năng một gói COTS (Phần 1.11) với tất cả (hoặc gần như tất cả) chức năng của sản phẩm phần mềm tùy chỉnh được đề xuất sẽ được đưa ra thị trường trong khi dự án đang được thực hiện hay không, và làm thế nào để xác định điều này?
	Vào cuối giai đoạn khởi động, các nhà phát triển cần câu trả lời cho những câu hỏi này để có thể đưa ra trường hợp kinh doanh ban đầu.
	
	Bước tiếp theo là xác định các rủi ro. Có ba loại rủi ro chính:
		1. Rủi ro kỹ thuật. Ví dụ về rủi ro kỹ thuật vừa được liệt kê.
		2. Không làm đúng yêu cầu. Rủi ro này có thể được giảm thiểu bằng cách thực hiện đúng quy trình yêu cầu.
		3. Không nhận được đúng kiến ​​trúc. Kiến trúc có thể không đủ chắc chắn. (Nhớ lại Phần 2.7 rằng kiến ​​trúc của một sản phẩm phần mềm bao gồm các thành phần khác nhau và cách chúng kết hợp với nhau, và đặc tính có thể xử lý các phần mở rộng và thay đổi mà không bị phân tách chính là tính mạnh mẽ của nó.) Nói cách khác, trong khi phần mềm sản phẩm đang được phát triển, có nguy cơ là cố gắng thêm phần tiếp theo vào phần đã được phát triển cho đến nay có thể yêu cầu toàn bộ kiến ​​trúc được thiết kế lại từ đầu. Một cách tương tự sẽ là xây dựng một ngôi nhà của các thẻ, chỉ để tìm thấy toàn bộ dinh thự sụp đổ khi một thẻ bổ sung được thêm vào.
		
	Các rủi ro cần được xếp hạng sao cho các rủi ro trọng yếu được giảm thiểu trước tiên.
	
	Như thể hiện trong Hình 3.1, một lượng nhỏ luồng công việc phân tích được thực hiện trong giai đoạn khởi động. Tất cả những gì thường làm là trích xuất thông tin cần thiết cho việc thiết kế kiến ​​trúc. Công việc thiết kế này cũng được phản ánh trong Hình 3.1.
	
	Bây giờ chuyển sang quy trình thực hiện, trong giai đoạn khởi động thường không có sự lập trình nào được thực hiện. Tuy nhiên, đôi khi cần phải xây dựng một nguyên mẫu bằng chứng khái niệm(proof-of-concept prototype) để kiểm tra tính khả thi của một phần sản phẩm phần mềm được đề xuất, như được mô tả trong Phần 2.9.7.
	
	Luồng công việc kiểm thử bắt đầu khi bắt đầu giai đoạn khởi động. Mục đích chính ở đây là đảm bảo rằng các yêu cầu được xác định chính xác.
	
	Lập kế hoạch là một phần thiết yếu của mọi giai đoạn. Trong trường hợp ở giai đoạn khởi đầu, các nhà phát triển không có đủ thông tin vào đầu giai đoạn để lập kế hoạch cho toàn bộ sự phát triển, do đó, việc lập kế hoạch duy nhất được thực hiện khi bắt đầu dự án là lập kế hoạch cho chính giai đoạn khởi đầu. Vì lý do tương tự, việc thiếu thông tin, việc lập kế hoạch duy nhất có thể được thực hiện một cách có ý nghĩa vào cuối giai đoạn khởi động là chỉ lập kế hoạch cho giai đoạn tiếp theo, giai đoạn xây dựng. 
	Tài liệu cũng vậy, là một phần thiết yếu của mọi giai đoạn. Các sản phẩm của giai đoạn khởi đầu bao gồm [Jacobson, Booch, và Rumbaugh, 1999]
		• Phiên bản ban đầu của mô hình miền.
		• Phiên bản ban đầu của mô hình nghiệp vụ.
		• Phiên bản ban đầu của các requirements artifact.
		• Một phiên bản sơ bộ của các analysis artifact.
		• Phiên bản sơ bộ của kiến ​​trúc.
		• Danh sách rủi ro ban đầu.
		• Các use case ban đầu (xem Chương 11).
		• Kế hoạch cho giai đoạn xây dựng.
		• Phiên bản ban đầu của trường hợp nghiệp vụ.
		
	Có được mục cuối cùng, phiên bản ban đầu của trường hợp nghiệp vụ, là mục tiêu tổng thể của giai đoạn khởi đầu. Phiên bản ban đầu này kết hợp mô tả về phạm vi của sản phẩm phần mềm cũng như các chi tiết tài chính. Nếu sản phẩm phần mềm được đề xuất được đưa ra thị trường, trường hợp kinh doanh bao gồm dự đoán doanh thu, ước tính thị trường và ước tính chi phí ban đầu. Nếu sản phẩm phần mềm được sử dụng nội bộ, trường hợp kinh doanh bao gồm phân tích chi phí - lợi ích ban đầu (Phần 5.2)

10.2. Elaboration phase
	Mục đích của giai đoạn sửa tỉ mỉ (bước thứ hai) là tinh chỉnh các yêu cầu ban đầu, tinh chỉnh kiến ​​trúc, giám sát các rủi ro và tinh chỉnh các ưu tiên của chúng, tinh chỉnh tình huống nghiệp vụ và đưa ra kế hoạch quản lý dự án phần mềm. Đây là lý do tên của giai đoạn này là Elaboration phase; các hoạt động chính của giai đoạn này là cải tiến hoặc sửa lại tỉ mỉ của giai đoạn trước.
	
	Hình 3.1 cho thấy rằng các tác vụ này tương ứng với tất cả trừ việc hoàn thành quy trình công việc yêu cầu (Chương 11), thực hiện hầu như toàn bộ luồng công việc phân tích (Chương 13), và sau đó bắt đầu thiết kế kiến ​​trúc (Phần 8.5.4).
	Các sản phẩm của giai đoạn xây dựng bao gồm [Jacobson, Booch, và Rumbaugh, 1999]
		• Mô hình miền đã hoàn thành.
		• Mô hình nghiệp vụ đã hoàn thiện.
		• Các requirements artifact đã hoàn thành.
		• Các analysis artifact đã hoàn thành.
		• Phiên bản cập nhật của kiến ​​trúc.
		• Một danh sách cập nhật các rủi ro.
		• Kế hoạch quản lý dự án phần mềm (cho phần còn lại của dự án).
		• Tình huống nghiệp vụ đã hoàn thành.

10.3. Construction phase
	Mục đích của giai đoạn xây dựng (bước thứ ba) là tạo ra phiên bản chất lượng hoạt động đầu tiên của sản phẩm phần mềm, cái gọi là bản phát hành beta (Phần 3.7.4). Xem xét lại Hình 3.1. Mặc dù con số chỉ là một biểu diễn tượng trưng của các giai đoạn, nhưng rõ ràng là trọng tâm trong giai đoạn này là triển khai và thử nghiệm sản phẩm phần mềm. Đó là, các thành phần khác nhau được mã hóa và kiểm tra đơn vị. Các code artifact sau đó được biên dịch và liên kết (tích hợp) để tạo thành các hệ thống con, được kiểm tra tích hợp. Cuối cùng, các hệ thống con được kết hợp thành hệ thống tổng thể, được kiểm tra sản phẩm. Điều này đã được mô tả trong Phần 3.7.4.
	
	Các sản phẩm của giai đoạn xây dựng bao gồm [Jacobson, Booch, và Rumbaugh, 1999]
		• Hướng dẫn sử dụng ban đầu và các hướng dẫn khác, nếu thích hợp.
		• Tất cả các hiện vật (phiên bản phát hành beta).
		• Kiến trúc đã hoàn thiện.
		• Danh sách rủi ro được cập nhật.
		• Kế hoạch quản lý dự án phần mềm (cho phần còn lại của dự án).
		• Nếu cần thiết, tình huống nghiệp vụ được cập nhật.

10.4. Transition phase
	Mục đích của giai đoạn chuyển đổi (bước tăng thứ tư) là đảm bảo rằng các yêu cầu của khách hàng đã thực sự được đáp ứng. Giai đoạn này được thúc đẩy bởi phản hồi từ các trang web đã cài đặt phiên bản beta. (Trong trường hợp sản phẩm phần mềm tùy chỉnh được phát triển cho một khách hàng cụ thể, chỉ có một trang web như vậy.) Các lỗi trong sản phẩm phần mềm được sửa chữa. Ngoài ra, tất cả các hướng dẫn đã được hoàn thành. Trong giai đoạn này, điều quan trọng là cố gắng phát hiện ra bất kỳ rủi ro nào chưa được xác định trước đó. (Tầm quan trọng của việc phát hiện rủi ro ngay cả trong giai đoạn chuyển đổi được nêu rõ trong Chỉ trong trường hợp bạn muốn biết ở Hộp 3.3.)
	
	Các sản phẩm của giai đoạn chuyển tiếp bao gồm [Jacobson, Booch, và Rumbaugh, 1999]
		• Tất cả các artifact(phiên bản cuối cùng).
		• Các hướng dẫn đã hoàn thành.

11. Mô hình vòng đời 1 với 2 chiều
	Mô hình vòng đời cổ điển (như mô hình thác nước của Phần 2.9.2) là mô hình một chiều, được biểu diễn bằng trục đơn trong Hình 3.2 (a). Bên dưới Unified Process là một mô hình vòng đời hai chiều, như được biểu diễn bằng hai trục trong Hình 3.2 (b).
	
	Bản chất một chiều của mô hình thác nước được phản ánh rõ ràng trong Hình 2.3. Ngược lại, Hình 2.2 cho thấy mô hình cây tiến hóa của nghiên cứu trường hợp nhỏ Winburg. Mô hình này là hai chiều và do đó nên được so sánh với Hình 3.2 (b).
	
	Các bổ sung sự phức tạp của mô hình hai chiều có cần thiết không? Câu trả lời đã được đưa ra trong Chương 2, nhưng đây là một vấn đề quan trọng nên nó được nhắc lại ở đây. Trong quá trình phát triển một sản phẩm phần mềm, trong một thế giới lý tưởng, quy trình công việc yêu cầu sẽ được hoàn thành trước khi chuyển sang luồng công việc phân tích. Tương tự, luồng công việc phân tích sẽ được hoàn thành trước khi bắt đầu quy trình công việc thiết kế, v.v. Tuy nhiên, trên thực tế, tất cả trừ các sản phẩm phần mềm tầm thường nhất đều quá lớn để xử lý như một đơn vị duy nhất. Thay vào đó, nhiệm vụ phải được chia thành từng phần (giai đoạn) và trong mỗi phần tăng dần, các nhà phát triển phải lặp lại cho đến khi họ hoàn thành nhiệm vụ đang được xây dựng. Là con người, chúng ta bị giới hạn bởi Định luật Miller [Miller, 1956], trong đó nói rằng chúng ta chỉ có thể chủ động xử lý bảy khái niệm cùng một lúc. Do đó, chúng tôi không thể xử lý tổng thể các sản phẩm phần mềm mà thay vào đó chúng tôi phải chia các hệ thống đó thành các hệ thống con. Ngay cả những hệ thống con đôi khi cũng có thể quá lớn — các thành phần có thể là tất cả những gì chúng ta có thể xử lý cho đến khi chúng ta hiểu đầy đủ hơn về toàn bộ sản phẩm phần mềm.
	
	Unified Process là giải pháp tốt nhất cho đến nay để xử lý một vấn đề lớn như một tập hợp các bài toán con nhỏ hơn, phần lớn độc lập. Nó cung cấp một khuôn khổ để gia tăng và lặp lại, cơ chế được sử dụng để đối phó với sự phức tạp của các sản phẩm phần mềm lớn.
	
	Một thách thức khác mà Unified Process xử lý tốt là những thay đổi không thể tránh khỏi. Một khía cạnh của thách thức này là những thay đổi trong yêu cầu của khách hàng trong khi sản phẩm phần mềm đang được phát triển, cái gọi là vấn đề mục tiêu di chuyển (Phần 2.4).
	
	Vì tất cả những lý do này, Unified Process hiện là phương pháp luận tốt nhất hiện có. Tuy nhiên, trong tương lai, Unified Process chắc chắn sẽ bị thay thế bởi một số phương pháp luận mới. Các chuyên gia phần mềm ngày nay đang nhìn xa hơn Unified Process để đạt được bước đột phá lớn tiếp theo. Rốt cuộc, trong hầu hết mọi lĩnh vực nỗ lực của con người, những khám phá của ngày nay thường vượt trội hơn bất cứ thứ gì được đưa ra trong quá khứ. Unified Process chắc chắn sẽ được thay thế bởi các phương pháp luận của tương lai. Bài học quan trọng là, dựa trên kiến ​​thức ngày nay, Unified Process dường như tốt hơn so với các giải pháp thay thế khác hiện có.
Phần còn lại của chương này được dành cho các sáng kiến ​​quốc gia và quốc tế nhằm cải tiến quy trình.

//Box 3.3

12. Cải thiện tiến trình phần mềm
	Nền kinh tế toàn cầu của chúng ta phụ thuộc rất nhiều vào máy tính và theo sau đó là phần mềm. Vì lý do này, chính phủ của nhiều quốc gia lo ngại về tiến trình phần mềm. Ví dụ, vào năm 1987, một lực lượng đặc nhiệm của Bộ Quốc phòng Hoa Kỳ (DoD) đã báo cáo, “Sau hai thập kỷ không thực hiện được những lời hứa về năng suất và chất lượng đạt được từ việc áp dụng các phương pháp và công nghệ phần mềm mới, các tổ chức công nghiệp và chính phủ đang nhận ra rằng vấn đề là không có khả năng quản lý tiến trình phần mềm ”[Brooks và cộng sự, 1987].
	Để giải quyết vấn đề này và những lo ngại liên quan, DoD đã thành lập Viện Kỹ thuật Phần mềm (SEI) và thành lập Viện này tại Đại học Carnegie Mellon ở Pittsburgh trên cơ sở quy trình mua sắm cạnh tranh. Một thành công lớn của SEI là sáng kiến mô hình phát triển năng lực (CMM). Các nỗ lực cải tiến tiến trình phần mềm liên quan bao gồm các tiêu chuẩn bộ ISO 9000 của Tổ chức Tiêu chuẩn hóa Quốc tế và ISO

13. Mô hình năng lực trưởng thành
	Các mô hình trưởng thành về năng lực(capability maturity models) của SEI là một nhóm các chiến lược có liên quan để cải tiến tiến trình phần mềm, bất kể mô hình vòng đời thực tế được sử dụng. (Thuật ngữ trưởng thành là thước đo mức độ tốt của chính quá trình.) SEI đã phát triển CMM cho phần mềm (SW – CMM), để quản lý nguồn nhân lực (P – CMM; P là viết tắt của “con người”), cho hệ thống kỹ thuật (SE – CMM), để phát triển sản phẩm tích hợp (IPD – CMM) và để mua lại phần mềm (SA – CMM). Có một số điểm không nhất quán giữa các mô hình và mức độ dư thừa không thể tránh khỏi. Theo đó, vào năm 1997, nó đã được quyết định phát triển một khung tích hợp duy nhất cho các mô hình trưởng thành, tích hợp mô hình trưởng thành năng lực (CMMI), trong đó kết hợp tất cả năm mô hình trưởng thành năng lực hiện có. Các ngành bổ sung có thể được thêm vào CMMI trong tương lai [SEI, 2002].
	Vì lý do không gian, chỉ có một mô hình phát triển năng lực, SW-CMM, được xem xét ở đây và tổng quan về P-CMM được đưa ra trong Phần 4.8. SW-CMM lần đầu tiên được đưa ra vào năm 1986 bởi Watts Humphrey [Humphrey, 1989]. Nhớ lại rằng một tiến trình phần mềm bao gồm các hoạt động, kỹ thuật và công cụ được sử dụng để sản xuất phần mềm. Do đó, nó kết hợp cả khía cạnh kỹ thuật và quản lý của sản xuất phần mềm. Cơ bản của SW-CMM là niềm tin rằng bản thân việc sử dụng các kỹ thuật phần mềm mới sẽ không làm tăng năng suất và lợi nhuận, bởi vì các vấn đề của chúng ta là do cách chúng ta quản lý tiến trình phần mềm. Chiến lược của SW-CMM là cải thiện việc quản lý tiến trình phần mềm với niềm tin rằng những cải tiến trong kỹ thuật là hệ quả tự nhiên. Kết quả là sự cải tiến trong toàn bộ quy trình sẽ dẫn đến phần mềm chất lượng tốt hơn và ít dự án phần mềm bị vượt quá thời gian và chi phí.
	Lưu ý rằng các cải tiến trong tiến trình phần mềm không thể xảy ra trong một sớm một chiều, SW – CMM tạo ra sự thay đổi từng bước. Cụ thể hơn, năm cấp độ trưởng thành được xác định và một tổ chức tiến bộ từ từ trong một loạt các bước tiến hóa nhỏ hướng tới các cấp độ trưởng thành cao hơn của quá trình [Paulk, Weber, Curtis, và Chrissis, 1995]. Để hiểu cách tiếp cận này, các cấp độ fi bây giờ được mô tả.

13.1. Maturity Level 1. Initial Level
	Ở cấp độ ban đầu, mức thấp nhất, về cơ bản không có thực hành quản lý kỹ thuật phần mềm đúng đắn nào được đưa ra trong tổ chức. Thay vào đó, mọi thứ được thực hiện trên cơ sở sự bộc phát. Một dự án cụ thể xảy ra để được nhân viên bởi một người quản lý có thẩm quyền và một đội ngũ phát triển phần mềm tốt có thể thành công. Tuy nhiên, mô hình thông thường là thời gian và chi phí vượt mức do thiếu quản lý âm thanh nói chung và quy hoạch nói riêng. Do đó, hầu hết các hoạt động đều phản ứng với các cuộc khủng hoảng hơn là các nhiệm vụ được chuẩn bị. Trong các tổ chức cấp 1, quá trình phần mềm không thể đoán trước, bởi vì nó phụ thuộc hoàn toàn vào nhân viên hiện tại; Khi nhân viên thay đổi, quá trình này cũng vậy. Do đó, không thể dự đoán được với bất kỳ độ chính xác nào mà các mặt hàng quan trọng như thời gian sẽ phải phát triển một sản phẩm hoặc chi phí của sản phẩm đó.
	Thật không may là đại đa số các tổ chức phần mềm trên toàn thế giới vẫn là tổ chức cấp 1

13.2. Maturity Level 2. Repeatable Level 
	Ở cấp độ lặp lại, các thực hành quản lý dự án phần mềm cơ bản được áp dụng. Kỹ thuật lập kế hoạch và quản lý dựa trên kinh nghiệm với các sản phẩm tương tự; do đó, tên có thể lặp lại. Ở cấp độ 2, các phép đo được thực hiện, một bước đầu tiên cần thiết để đạt được một quy trình đầy đủ. Các phép đo thông thường bao gồm việc theo dõi tỉ mỉ chi phí và lịch trình. Thay vì hoạt động theo chế độ khủng hoảng, như ở cấp độ 1, các nhà quản lý xác định các vấn đề khi chúng nảy sinh và thực hiện hành động khắc phục ngay lập tức để ngăn chúng trở thành khủng hoảng. Điểm mấu chốt là, nếu không có phép đo, không thể phát hiện ra các vấn đề trước khi chúng lọt khỏi tầm tay. Ngoài ra, các phép đo được thực hiện trong một dự án có thể được sử dụng để lập lịch trình chi phí và thời lượng thực tế cho các dự án trong tương lai.

13.3. Maturity Level 3. Defined Level
	Ở cấp độ xác định, quy trình sản xuất phần mềm được ghi lại đầy đủ. Cả khía cạnh quản lý và kỹ thuật của quy trình đều được xác định rõ ràng và các nỗ lực liên tục được thực hiện để cải tiến quy trình nếu có thể. Đánh giá (Phần 6.2) được sử dụng để đạt được các mục tiêu chất lượng phần mềm. Ở cấp độ này, việc giới thiệu công nghệ mới, chẳng hạn như môi trường CASE (Phần 5.8), là hợp lý để tăng chất lượng và năng suất hơn nữa. Ngược lại, “công nghệ cao” chỉ làm cho quy trình cấp 1 do khủng hoảng điều khiển càng trở nên hỗn loạn hơn.
	Mặc dù một số tổ chức đã đạt được cấp độ trưởng thành 2 và 3, nhưng một số ít đã đạt đến cấp độ 4 hoặc 5. Do đó, hai cấp độ cao nhất là mục tiêu cho tương lai.

13.4. Maturity Level 4. Managed Level
	Một tổ chức cấp quản lý đặt ra các mục tiêu về chất lượng và năng suất cho mỗi dự án. Hai đại lượng này được đo liên tục và hành động khắc phục được thực hiện khi có những sai lệch không thể chấp nhận được so với mục tiêu. Các biện pháp kiểm soát chất lượng thống kê ([Deming, 1986], [Juran, 1988]) được thực hiện để cho phép ban lãnh đạo phân biệt sự sai lệch ngẫu nhiên với sự vi phạm có ý nghĩa các tiêu chuẩn chất lượng hoặc năng suất. (Một ví dụ đơn giản về biện pháp kiểm soát chất lượng thống kê là số lỗi được phát hiện trên 1000 dòng mã. Mục tiêu tương ứng là giảm số lượng này theo thời gian.) 

13.5. Maturity Level 5. Optimizing Level 
	Mục tiêu của một tổ chức cấp độ tối ưu hóa là cải tiến quy trình liên tục. Các kỹ thuật kiểm soát quá trình và chất lượng thống kê được sử dụng để hướng dẫn tổ chức. Kiến thức thu được từ mỗi dự án sẽ được sử dụng trong các dự án trong tương lai. Do đó, quá trình kết hợp một vòng phản hồi tích cực, dẫn đến sự cải thiện ổn định về năng suất và chất lượng.
	
--

	Năm cấp độ trưởng thành này được tóm tắt trong Hình 3.3, cũng cho thấy các lĩnh vực quy trình chính (key process areas - KPA) liên quan đến từng cấp độ trưởng thành. Để cải thiện tiến trình phần mềm của mình, trước tiên tổ chức cố gắng hiểu được quy trình hiện tại của mình và sau đó xây dựng quy trình dự kiến. Tiếp theo, các hành động để đạt được cải tiến quy trình này được xác định và xếp hạng ưu tiên. Cuối cùng, một kế hoạch để thực hiện cải tiến này được lập và thực hiện. Chuỗi các bước này được lặp lại, với việc tổ chức cải tiến liên tục tiến trình phần mềm của mình; sự tiến triển này từ cấp độ này sang cấp độ khác được phản ánh trong Hình 3.3. Kinh nghiệm với mô hình trưởng thành năng lực cho thấy rằng để đạt được mức trưởng thành hoàn toàn thường mất từ 18 tháng đến 3 năm, nhưng chuyển từ cấp độ 1 lên cấp độ 2 đôi khi có thể mất 3 hoặc thậm chí 5 năm. Đây là sự phản ánh khó khăn như thế nào để áp dụng một phương pháp tiếp cận có phương pháp trong một tổ chức mà cho đến nay vẫn hoạt động trên cơ sở hoàn toàn mang tính đột xuất và phản ứng.
	
	Đối với mỗi cấp độ trưởng thành, SEI đã nêu bật một loạt các lĩnh vực quy trình chính (KPA) mà một tổ chức nên nhắm mục tiêu trong nỗ lực đạt được cấp độ trưởng thành tiếp theo. Ví dụ, như trong Hình 3.3, các KPA cho mức 2 (mức lặp lại) bao gồm quản lý cấu hình (Phần 5.10), đảm bảo chất lượng phần mềm (Phần 6.1.1), lập kế hoạch dự án (Chương 9), theo dõi dự án (Phần 9.2.5 ), và quản lý yêu cầu (Chương 11). Các lĩnh vực này bao gồm các yếu tố cơ bản của quản lý phần mềm: Xác định nhu cầu của khách hàng (quản lý yêu cầu), lập kế hoạch (lập kế hoạch dự án), giám sát các sai lệch so với kế hoạch đó (theo dõi dự án), kiểm soát các phần khác nhau tạo nên quy trình chính của sản phẩm phần mềm khu vực (quản lý điều chỉnh), và đảm bảo rằng sản phẩm không có lỗi (đảm bảo chất lượng). Trong mỗi KPA là một nhóm gồm từ hai đến bốn mục tiêu liên quan mà nếu đạt được sẽ dẫn đến việc đạt được mức trưởng thành đó. Ví dụ, một mục tiêu lập kế hoạch dự án là phát triển một kế hoạch bao gồm các hoạt động phát triển phần mềm một cách phù hợp và thực tế.
	
	Ở cấp độ cao nhất, cấp độ trưởng thành 5, các KPA bao gồm ngăn ngừa lỗi, quản lý thay đổi công nghệ và quản lý thay đổi quy trình. So sánh KPA của hai cấp độ, rõ ràng là tổ chức cấp độ 5 vượt xa so với tổ chức cấp độ 2. Ví dụ, tổ chức cấp độ 2 quan tâm đến đảm bảo chất lượng phần mềm, nghĩa là phát hiện và sửa lỗi. (chất lượng phần mềm được thảo luận chi tiết hơn trong Chương 6). Ngược lại, quy trình của tổ chức cấp độ 5 kết hợp phòng ngừa lỗi, tức là cố gắng đảm bảo rằng không có lỗi nào trong phần mềm ngay từ đầu. Để giúp một tổ chức đạt được các cấp độ trưởng thành cao hơn, SEI đã phát triển một loạt các bảng câu hỏi làm cơ sở cho việc đánh giá của một nhóm SEI. Mục đích của việc đánh giá là làm nổi bật những thiếu sót hiện tại trong tiến trình phần mềm của tổ chức và chỉ ra những cách mà tổ chức có thể cải thiện quy trình của mình.
Chương trình CMM của Viện Kỹ thuật Phần mềm được Bộ Quốc phòng Hoa Kỳ tài trợ. Một trong những mục tiêu ban đầu của chương trình CMM là nâng cao chất lượng của phần mềm quốc phòng bằng cách đánh giá quy trình của các nhà thầu sản xuất phần mềm cho DoD và trao hợp đồng cho những nhà thầu nào chứng minh được quy trình trưởng thành. Không quân Hoa Kỳ quy định rằng bất kỳ tổ chức phát triển phần mềm nào muốn trở thành nhà thầu của Lực lượng Không quân phải tuân thủ SW-CMM cấp 3 vào năm 1998 và DoD nói chung sau đó đã ban hành một chỉ thị tương tự. Do đó, các tổ chức đặt ra áp lực phải cải thiện sự hoàn thiện của các tiến trình phần mềm của họ. Tuy nhiên, chương trình SW-CMM đã vượt xa mục tiêu hạn chế là cải tiến phần mềm DoD và đang được thực hiện bởi nhiều tổ chức phần mềm mong muốn cải thiện chất lượng và năng suất phần mềm.

14. Các sáng kiến cải tiến tiến trình phần mềm khác
	Một nỗ lực khác nhằm cải thiện chất lượng phần mềm dựa trên các tiêu chuẩn series 9000 của Tổ chức Tiêu chuẩn hóa Quốc tế (ISO), một loạt năm tiêu chuẩn liên quan áp dụng cho nhiều hoạt động công nghiệp, bao gồm thiết kế, phát triển, sản xuất, cài đặt và bảo dưỡng; ISO 9000 chắc chắn không chỉ là một tiêu chuẩn phần mềm. Trong bộ tiêu chuẩn ISO 9000, tiêu chuẩn ISO 9001 [1987] cho hệ thống chất lượng là tiêu chuẩn áp dụng nhiều nhất cho việc phát triển phần mềm. Do tính rộng của ISO 9001, ISO đã công bố các hướng dẫn cụ thể để hỗ trợ việc áp dụng ISO 9001 vào phần mềm: ISO 9000-3 [1991]. (Để biết thêm thông tin về ISO, hãy xem Chỉ trong trường hợp bạn muốn biết ở Hộp 1.4.)
ISO 9000 có một số đặc điểm phân biệt nó với CMM [Dawood, 1994]. ISO 9000 nhấn mạnh việc ghi lại quy trình bằng cả lời nói và hình ảnh để đảm bảo tính nhất quán và dễ hiểu. Ngoài ra, triết lý của ISO 9000 là việc tuân thủ tiêu chuẩn không đảm bảo sản phẩm chất lượng cao mà là giảm nguy cơ sản phẩm kém chất lượng. ISO 9000 chỉ là một phần của hệ thống chất lượng. Các cam kết của ban lãnh đạo đối với chất lượng, đào tạo chuyên sâu công nhân cũng như thiết lập và đạt được các mục tiêu để cải tiến chất lượng liên tục. Bộ tiêu chuẩn ISO 9000 đã được hơn 60 quốc gia, bao gồm Hoa Kỳ, Nhật Bản, Canada và các nước thuộc Liên minh Châu Âu (EU) áp dụng. Điều này có nghĩa là, ví dụ, nếu một tổ chức phần mềm của Hoa Kỳ muốn kinh doanh với một khách hàng Châu Âu, thì tổ chức Hoa Kỳ trước tiên phải được chứng nhận là tuân thủ ISO 9000. Công ty đăng ký được chứng nhận (đánh giá viên) phải kiểm tra quy trình của công ty và chứng nhận rằng nó tuân thủ tiêu chuẩn ISO.

	Theo sau các đối tác châu Âu của họ, ngày càng nhiều tổ chức Hoa Kỳ yêu cầu cấp chứng chỉ ISO 9000. Ví dụ, General Electric Plastic Division khẳng định rằng 340 nhà cung cấp đạt được tiêu chuẩn vào tháng 6 năm 1993 [Dawood, 1994]. Không có khả năng chính phủ Hoa Kỳ sẽ tuân theo sự dẫn dắt của EU và yêu cầu tuân thủ ISO 9000 đối với các công ty ngoài Hoa Kỳ muốn kinh doanh với các tổ chức ở Hoa Kỳ. Tuy nhiên, áp lực cả trong Hoa Kỳ và từ các đối tác thương mại lớn của nó cuối cùng có thể dẫn đến việc không tuân thủ ISO 9000 trên toàn thế giới.
	
	ISO / IEC 15504 là một sáng kiến cải tiến quy trình quốc tế, giống như ISO 9000. Sáng kiến này trước đây được gọi là SPICE, một từ viết tắt được hình thành từ dEtermination khả năng cải tiến tiến trình phần mềm. Hơn 40 quốc gia đã đóng góp tích cực vào nỗ lực SPICE. SPICE do Bộ Quốc phòng Anh (MOD) khởi xướng với mục đích lâu dài là thiết lập SPICE như một tiêu chuẩn quốc tế (MOD là đối tác của Vương quốc Anh với DoD Hoa Kỳ, đơn vị khởi xướng CMM). Phiên bản đầu tiên của SPICE được hoàn thành vào năm 1995. Vào tháng 7 năm 1997, sáng kiến SPICE đã được một ủy ban chung của Tổ chức Tiêu chuẩn hóa Quốc tế và Ủy ban Kỹ thuật Điện Quốc tế tiếp quản. Vì lý do này, tên của sáng kiến đã được đổi từ SPICE thành ISO

15. Chi phí và lợi ích của việc cải tiến tiến trình phần mềm
	Việc thực hiện cải tiến tiến trình phần mềm có dẫn đến tăng lợi ích không? Kết quả chỉ ra trong các trường hợp dưới đây. Ví dụ, Bộ phận Kỹ thuật Phần mềm của Hughes Aircraft ở Fullerton, California, đã chi gần 500.000 đô la từ năm 1987 đến năm 1990 cho các chương trình đánh giá và cải tiến [Humphrey, Snider và Willis, 1991]. Trong khoảng thời gian 3 năm này, Hughes Aircraft đã chuyển từ cấp độ trưởng thành 2 lên cấp độ 3, với mọi kỳ vọng sẽ cải thiện trong tương lai lên cấp độ 4 và thậm chí là cấp độ 5. Kết quả của việc cải thiện quy trình của mình, Hughes Aircraft ước tính khoản tiết kiệm hàng năm của mình sẽ vào đơn đặt hàng 2 triệu đô la. Những khoản tiết kiệm này được tích lũy theo một số cách, bao gồm giảm số giờ làm thêm, ít khủng hoảng hơn, tinh thần nhân viên được cải thiện và doanh thu của các chuyên gia phần mềm thấp hơn.
	
	Kết quả so sánh đã được báo cáo tại các tổ chức khác. Ví dụ, Bộ phận Thiết bị tại Raytheon đã chuyển từ cấp 1 vào năm 1988 lên cấp 3 vào năm 1993. Năng suất tăng gấp hai lần, cũng như thu về 7,70 đô la cho mỗi đô la đầu tư vào nỗ lực cải tiến quy trình [Dion, 1993]. Do những kết quả như thế này, các mô hình phát triển năng lực đang được áp dụng khá rộng rãi trong ngành công nghiệp phần mềm Hoa Kỳ và ở nước ngoài.
	
	Ví dụ, Dịch vụ Tư vấn Tata ở Ấn Độ đã sử dụng cả khuôn khổ ISO 9000 và CMM để cải thiện quy trình của mình [Keeni, 2000]. Từ năm 1996 đến năm 2000, sai số trong ước tính nỗ lực giảm từ khoảng 50% xuống chỉ còn 15%. Hiệu quả của các bài đánh giá (nghĩa là phần trăm lỗi được tìm thấy trong các bài đánh giá) tăng từ 40 lên 80 phần trăm. Phần trăm nỗ lực dành cho việc làm lại các dự án giảm từ gần 12 phần trăm xuống dưới 6 phần trăm.
	
	Bộ phận Điện tử Chính phủ Motorola (GED) đã tích cực tham gia vào chương trình cải tiến tiến trình phần mềm của SEI kể từ năm 1992 [Diaz và Sligo, 1997]. Hình 3.4 mô tả 34 dự án GED, được phân loại theo mức độ trưởng thành của nhóm đã phát triển từng dự án. Như có thể thấy trong hình, thời lượng tương đối (nghĩa là thời gian của một dự án so với dự án cơ sở hoàn thành trước năm 1992) giảm khi mức độ trưởng thành ngày càng tăng. Chất lượng được đo lường về lỗi trên một triệu dòng nguồn lắp ráp tương đương (MEASL); để có thể so sánh các dự án được thực hiện bằng các ngôn ngữ khác nhau, số dòng mã nguồn đã được chuyển đổi thành số dòng tương đương của mã trình hợp dịch [Jones, 1996]. Như trong Hình 3.4, chất lượng tăng lên khi mức độ chín tăng dần. Cuối cùng, năng suất được đo bằng MEASL mỗi người-giờ. Vì lý do bảo mật, Motorola không công bố số liệu năng suất thực tế, vì vậy Hình 3.4 phản ánh năng suất so với năng suất của dự án cấp 2. (Không có số liệu về chất lượng hoặc năng suất cho các dự án cấp 1 vì những đại lượng này không thể đo được khi nhóm ở cấp độ 1)
	
	Galin và Avrahami [2006] đã phân tích 85 dự án trước đây đã được báo cáo trong tài liệu là đã tiến thêm một cấp do kết quả của việc thực hiện CMM. Các dự án này được chia thành bốn nhóm (CMM cấp độ 1 đến cấp độ 2, CMM cấp độ 2 đến cấp độ 3, v.v.). Đối với bốn nhóm, mật độ lỗi trung bình (số lỗi trên mỗi KLOC) giảm từ 26 đến 63 phần trăm. Năng suất trung bình (KLOC / người / tháng) tăng từ 26 đến 187 phần trăm. Làm lại trung bình giảm từ 34 đến 40 phần trăm. Thời lượng trung bình của dự án giảm từ 28 đến 53 phần trăm. Hiệu quả phát hiện lỗi (tỷ lệ lỗi được phát hiện trong quá trình phát triển trong tổng số lỗi của dự án được phát hiện) tăng lên như sau: Đối với ba nhóm thấp nhất, mức trung bình tăng từ 70 đến 74% và 13% đối với nhóm cao nhất (CMM cấp 4 đến cấp 5). Lợi tức đầu tư dao động trong khoảng 120 đến 650 phần trăm, với giá trị trung bình là 360 phần trăm.
	Do kết quả của các nghiên cứu đã xuất bản như những nghiên cứu được mô tả trong phần này và những nghiên cứu được liệt kê trong phần Đọc thêm của chương này, ngày càng nhiều tổ chức trên toàn thế giới nhận ra rằng cải tiến quy trình là hiệu quả về chi phí.
	
	 Một tác dụng phụ thú vị của phong trào cải tiến quy trình là sự tương tác giữa các sáng kiến ​​cải tiến tiến trình phần mềm và các tiêu chuẩn kỹ thuật phần mềm. Ví dụ, vào năm 1995, Tổ chức Tiêu chuẩn hóa Quốc tế đã công bố
	 
	ISO / IEC 12207, một tiêu chuẩn phần mềm vòng đời đầy đủ [ISO / IEC 12207, 1995]. Ba năm sau, phiên bản Hoa Kỳ của tiêu chuẩn [IEEE / EIA 12207.0-1996, 1998] đã được xuất bản bởi Viện Kỹ sư Điện và Điện tử (IEEE) và Liên minh Công nghiệp Điện tử (EIA). Phiên bản này kết hợp “các phương pháp hay nhất” về phần mềm của Hoa Kỳ, nhiều phương pháp trong số đó có thể được truy nguyên từ CMM. Để đạt được sự tuân thủ IEEE / EIA 12207, một tổ chức phải đạt hoặc gần năng lực CMM cấp độ 3 [Ferguson và Sheard, 1998]. Ngoài ra, ISO 9000-3 hiện kết hợp các phần của ISO / IEC 12207. Sự tương tác này giữa các tổ chức tiêu chuẩn kỹ thuật phần mềm và các sáng kiến ​​cải tiến tiến trình phần mềm chắc chắn sẽ dẫn đến các tiến trình phần mềm tốt hơn nữa.
	
	 Một khía cạnh khác của cải tiến tiến trình phần mềm xuất hiện trong Chỉ trong trường hợp bạn muốn Cần biết Hộp 3.4.




