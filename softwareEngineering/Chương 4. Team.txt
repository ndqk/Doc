Mục tiêu học tập Sau khi nghiên cứu chương này, bạn sẽ có thể 
• Giải thích tầm quan trọng của một nhóm được tổ chức tốt. 
• Mô tả cách tổ chức các nhóm phân cấp hiện đại. 
• Phân tích điểm mạnh và điểm yếu của một loạt các tổ chức nhóm khác nhau. 
• Đánh giá cao các vấn đề nảy sinh khi lựa chọn một tổ chức nhóm thích hợp.

Nếu không có các kỹ sư phần mềm có năng lực, được đào tạo bài bản, một dự án phần mềm sẽ thất bại. Tuy nhiên, có người là chưa đủ; các nhóm phải được tổ chức theo cách mà các thành viên trong nhóm có thể làm việc hiệu quả trong sự hợp tác với nhau. Tổ chức nhóm là chủ đề của chương này.

4.1 Tổ chức nhóm
	Hầu hết các sản phẩm quá lớn để được hoàn thành bởi một chuyên gia phần mềm duy nhất trong thời hạn nhất định. Do đó, sản phẩm phải được giao cho một nhóm các chuyên gia được tổ chức như  một team. Ví dụ, hãy xem xét quy trình phân tích. Để xác định sản phẩm mục tiêu trong vòng 2 tháng, có thể cần giao nhiệm vụ cho ba chuyên gia phân tích được tổ chức thành một nhóm dưới sự chỉ đạo của trưởng phòng phân tích. Tương tự, nhiệm vụ thiết kế có thể được chia sẻ giữa các thành viên trong nhóm thiết kế.

	Giả sử bây giờ một sản phẩm phải được code trong vòng 3 tháng, một người thì sẽ mất 1 năm để thực hiện x. Giải pháp rõ ràng là đơn giản: Nếu một lập trình viên có thể viết mã sản phẩm trong 1 năm, thì 4 lập trình viên có thể làm điều đó trong 3 tháng.

	Điều này tất nhiên không đúng như vậy. Trong thực tế, bốn lập trình viên có thể mất gần một năm và chất lượng của sản phẩm thu được cũng có thể thấp hơn nếu một lập trình viên code toàn bộ sản phẩm. Lý do là một số nhiệm vụ có thể được chia sẻ, nhưng những nhiệm vụ khác phải được thực hiện riêng lẻ. Ví dụ, nếu một người nông dân có thể hái một cánh đồng dâu tây trong 10 ngày, thì cùng một cánh đồng dâu tây có thể được hái bởi 10 người nông dân trong một ngày. Mặt khác, một con voi có thể sinh ra một con bê trong 22 tháng, nhưng kỳ tích này không thể đạt được trong 1 tháng bởi 22 con voi.

	Nói cách khác, những công việc như hái dâu hoàn toàn có thể được chia sẻ; những người khác, nhưng trường hợp khác lại không thể được chia sẻ chút nào. Không giống như sản xuất voi, có thể chia sẻ nhiệm vụ thực hiện giữa các thành viên trong nhóm bằng cách phân chia code giữa các thành viên trong nhóm. Tuy nhiên, lập trình nhóm cũng không giống như hái dâu ở chỗ các thành viên trong nhóm phải tương tác với nhau một cách có ý nghĩa và hiệu quả. Ví dụ, giả sử Sheila và Harry phải code hai mô-đun, m1 và m2. Một số điều có thể xảy ra sai lầm. Ví dụ, cả Sheila và Harry đều có thể mã m1 và bỏ qua m2. Hoặc Sheila có thể mã m1, và Harry có thể mã m2. Nhưng khi m1 gọi m2, nó vượt qua bốn đối số; Harry đã mã hóa m2 theo cách mà nó yêu cầu năm đối số. Hoặc thứ tự của các đối số trong m1 và m2 có thể khác nhau. Hoặc thứ tự có thể giống nhau, nhưng các kiểu dữ liệu có thể hơi khác nhau. Những vấn đề như vậy thường là do một quyết định được đưa ra trong khi quy trình thiết kế được thực hiện mà không được phổ biến trong toàn bộ tổ chức phát triển. Vấn đề không liên quan gì đến năng lực kỹ thuật của các lập trình viên. Tổ chức đội là một vấn đề quản lý; ban lãnh đạo phải tổ chức các nhóm lập trình để mỗi nhóm có năng suất cao.

	Một loại khó khăn khác phát sinh từ việc phát triển phần mềm của nhóm được thể hiện trong Hình 4.1. Ba kênh liên lạc tồn tại giữa ba chuyên gia phần mềm làm việc trong dự án. Bây giờ, giả sử rằng công việc đang trôi chảy, thời hạn đang đến nhanh chóng và nhiệm vụ gần như không hoàn thành. Điều hiển nhiên cần làm là thêm chuyên gia thứ tư vào đội. Nhưng điều đầu tiên phải xảy ra khi chuyên gia thứ tư gia nhập đội là để ba người còn lại giải thích chi tiết những gì đã hoàn thành cho đến nay và những gì vẫn chưa hoàn thành. Nói cách khác, việc bổ sung nhân sự vào một dự án phần mềm muộn sẽ khiến nó thậm chí còn muộn hơn. Nguyên tắc này được gọi là Luật Brooks theo tên Fred Brooks, người đã quan sát nó trong khi quản lý việc phát triển OS/360 [Brooks, 1975], một hệ điều hành cho máy tính máy tính lớn IBM 360.

	Trong một tổ chức lớn, các nhóm được sử dụng trong mọi quy trình sản xuất phần mềm, nhưng đặc biệt là khi quy trình cài đặt được thực hiện; trong quy trình làm việc đó, các lập trình viên làm việc độc lập trên các code artifact riêng biệt. Theo đó, quy trình cài đặt là một ứng cử viên hàng đầu để chia sẻ nhiệm vụ giữa một số chuyên gia phần mềm. Trong một số tổ chức nhỏ hơn, một cá nhân có thể chịu trách nhiệm về các yêu cầu, phân tích và thiết kế, sau đó việc triển khai được thực hiện bởi một nhóm gồm hai hoặc ba lập trình viên. Bởi vì các nhóm được sử dụng nhiều nhất khi thực hiện quy trình cài đặt, các vấn đề về tổ chức nhóm được cảm nhận một cách sâu sắc nhất trong quá trình cài đặt. Do đó, trong phần còn lại của chương này, tổ chức nhóm được trình bày trong bối cảnh quy trình cài đặt, mặc dù các vấn đề và giải pháp của chúng đều có thể áp dụng như nhau cho tất cả các quy trình công việc khác.

	Có hai cách tiếp cận cực đoan đối với tổ chức nhóm lập trình, emocratic teams và chief programmer teams. Cách tiếp cận được thực hiện ở đây là mô tả từng cách tiếp cận trong số hai cách tiếp cận, nêu bật điểm mạnh và điểm yếu của nó, sau đó đề xuất các cách khác để tổ chức một nhóm lập trình kết hợp các tính năng tốt nhất của hai thái cực.


4.2 Democratic Team Approach (Nhóm bình đẳng/dân chủ)
	Tổ chức Democratic Team được Weinberg mô tả lần đầu tiên vào năm 1971 [Weinberg, 1971]. Khái niệm cơ bản làm nền tảng cho democratic team là egoless programming. Weinberg chỉ ra rằng các lập trình viên có thể rất gắn bó với code của họ. Đôi khi, họ thậm chí đặt tên các mô-đun của mình theo tên chính họ: Do đó, họ xem các mô-đun của họ như một phần mở rộng của chính họ. Khó khăn với điều này là một lập trình viên coi mô-đun như một phần mở rộng của bản ngã của mình chắc chắn sẽ không cố gắng tìm ra tất cả các lỗi trong code “của anh ấy” hoặc code “của cô ấy”. Và, nếu có lỗi, nó được gọi là lỗi, giống như một con côn trùng nào đó chui vào code và có thể bị ngăn chặn nếu code được bảo vệ cẩn thận hơn để chống lại sự xâm nhập (xem Chỉ trong trường hợp bạn muốn biết Hộp 4.1 ).

	Giải pháp của Weinberg cho vấn đề các lập trình viên gắn bó quá chặt chẽ với code riêng của họ là egoless programming. Môi trường xã hội phải được tái cấu trúc và các giá trị của lập trình viên cũng vậy. Mỗi lập trình viên phải khuyến khích các thành viên khác trong nhóm tìm ra lỗi trong code của mình. Sự hiện diện của một lỗi không được coi là một điều gì đó xấu mà là một sự kiện bình thường và được chấp nhận; thái độ của người đánh giá nên được đánh giá cao khi được yêu cầu lời khuyên, thay vì chế nhạo lập trình viên vì đã mắc lỗi khi code. Cả nhóm cùng phát triển một đặc tính, một bản sắc nhóm; và các mô-đun thuộc về toàn bộ nhóm thay vì bất kỳ cá nhân nào.

	Một nhóm có tới 10 lập trình viên vô ngã tạo thành một democratic team. Weinberg cảnh báo rằng ban lãnh đạo có thể gặp khó khăn khi làm việc với một nhóm như vậy. Sau cùng, hãy xem xét con đường sự nghiệp của nhà quản lý. Khi một lập trình viên được thăng chức lên vị trí quản lý, các lập trình viên của họ không được thăng chức và phải phấn đấu để đạt được cấp độ cao hơn ở các đợt thăng cấp tiếp theo. Ngược lại, một nhóm dân chủ là một nhóm làm việc vì một mục tiêu chung, không có lãnh đạo duy nhất, không có lập trình viên nào đang cố gắng được thăng cấp lên cấp độ tiếp theo. Điều quan trọng là bản sắc đồng đội và sự tôn trọng lẫn nhau.

	Weinberg kể về một nhóm dân chủ đã phát triển một sản phẩm xuất sắc. Ban quản lý đã quyết định trao phần thưởng tiền mặt cho người quản lý danh nghĩa của nhóm (theo định nghĩa, một nhóm dân chủ không có lãnh đạo). Ông từ chối nhận nó một cách cá nhân, nói rằng nó phải được chia đều cho tất cả các thành viên trong nhóm. Ban lãnh đạo nghĩ rằng anh ta đang muốn kiếm nhiều tiền hơn và nhóm (và đặc biệt là người quản lý danh nghĩa) có một số ý tưởng không chính thống. Ban quản lý buộc người quản lý danh nghĩa phải nhận tiền, sau đó anh ta chia đều cho cả đội. Tiếp theo, toàn bộ đội từ chức và gia nhập một công ty khác với tư cách là một đội.
	Những điểm mạnh và điểm yếu của các đội dân chủ bây giờ đã được trình bày.

4.2.1 Analysis of the Democratic Team Approach 
	Một điểm mạnh chính của phương pháp tiếp cận theo nhóm bình đẳng là thái độ tích cực đối với việc tìm ra lỗi. Càng tìm thấy nhiều, càng hạnh phúc khi là thành viên của một đội dân chủ. Thái độ tích cực này dẫn đến việc phát hiện lỗi nhanh hơn và do đó tạo ra code chất lượng cao. Nhưng có một số vấn đề lớn. Như đã chỉ ra trước đây, các nhà quản lý có thể gặp khó khăn trong việc chấp nhận lập trình vô ngã. Ngoài ra, một lập trình viên với 15 năm kinh nghiệm có thể sẽ bực bội khi bị các lập trình viên đồng nghiệp đánh giá code của mình, đặc biệt là những người mới bắt đầu.

	Weinberg cảm thấy rằng các đội vô ngã mọc lên một cách tự nhiên và không thể bị áp đặt từ bên ngoài. Nghiên cứu thử nghiệm nhỏ đã được thực hiện đối với các nhóm lập trình dân chủ, nhưng kinh nghiệm của Weinberg là các nhóm dân chủ có năng suất rất cao. Mantei [1981] đã phân tích tổ chức nhóm dân chủ bằng cách sử dụng các lập luận dựa trên các lý thuyết và thử nghiệm về tổ chức nhóm nói chung chứ không phải cụ thể trên các nhóm lập trình. Cô chỉ ra rằng các nhóm phi tập trung hoạt động tốt nhất khi vấn đề khó khăn và gợi ý rằng các nhóm dân chủ nên hoạt động tốt trong môi trường nghiên cứu. Kinh nghiệm của tôi là một nhóm dân chủ cũng hoạt động tốt trong môi trường công nghiệp khi một vấn đề khó khăn phải được giải quyết. Trong một số trường hợp, tôi là thành viên của các nhóm dân chủ đã phát triển một cách tự phát giữa các chuyên gia phần mềm có kinh nghiệm nghiên cứu. Tuy nhiên, khi nhiệm vụ đã được giảm xuống thành việc thực hiện giải pháp hardwon, nhóm sau đó phải được tổ chức lại theo cách phân cấp hơn, chẳng hạn như phương pháp tiếp cận của nhóm lập trình viên trưởng được mô tả trong Phần 4.3.

4.3 Classical Chief Programmer Team Approach  (Nhóm có sếp kiểu cũ)
	Hãy xem xét nhóm sáu người được thể hiện trong Hình 4.2, với 15 kênh giao tiếp hai người. Trên thực tế, tổng số nhóm hai, ba, bốn, nhóm và sáu người là 57. Sự đa dạng của các kênh liên lạc là lý do chính khiến một nhóm sáu người được cấu trúc như trong Hình 4.2 là không thể. có khả năng thực hiện 36 tháng công việc trong 6 tháng; nhiều giờ bị lãng phí trong các cuộc họp liên quan đến hai hoặc nhiều thành viên trong nhóm cùng một lúc.

	Bây giờ hãy xem xét nhóm sáu người được thể hiện trong Hình 4.3. Một lần nữa, có sáu lập trình viên, nhưng bây giờ chỉ có năm đường dây liên lạc. Đây là khái niệm cơ bản đằng sau những gì bây giờ được gọi là nhóm lập trình có sếp. Một ý tưởng liên quan được đưa ra bởi Brooks [1975], người đã đưa ra sự tương tự về một bác sĩ phẫu thuật trưởng chỉ đạo một ca phẫu thuật. Bác sĩ phẫu thuật được hỗ trợ bởi các bác sĩ phẫu thuật khác, bác sĩ gây mê và nhiều y tá. Ngoài ra, khi cần thiết, nhóm còn sử dụng các chuyên gia trong các lĩnh vực khác, chẳng hạn như bác sĩ tim mạch hoặc bác sĩ thận học. Sự tương tự này làm nổi bật hai khía cạnh chính của nhóm lập trình viên trưởng. Đầu tiên là chuyên môn hóa: Mỗi thành viên trong nhóm chỉ thực hiện những nhiệm vụ mà họ đã được đào tạo. Khía cạnh thứ hai là thứ bậc: Bác sĩ phẫu thuật trưởng chỉ đạo hành động của tất cả các thành viên khác trong nhóm và chịu trách nhiệm về mọi khía cạnh của hoạt động.

	Khái niệm nhóm lập trình có xếp được Mills chính thức hóa [Baker, 1972]. Một nhóm lập trình có sếp cổ điển, như được mô tả bởi Baker khoảng 40 năm trước, được thể hiện trong Hình 4.3. Nó bao gồm lập trình viên trưởng, người được hỗ trợ bởi lập trình viên dự phòng, thư ký lập trình và từ một đến ba lập trình viên. Khi cần thiết, nhóm được hỗ trợ bởi các chuyên gia trong các lĩnh vực khác, chẳng hạn như các vấn đề pháp lý hoặc tài chính, hoặc các tuyên bố về ngôn ngữ kiểm soát công việc (JCL) được sử dụng để cung cấp các lệnh của hệ điều hành cho các máy tính lớn của thời đại đó. Lập trình viên trưởng vừa là một nhà quản lý thành công vừa là một lập trình viên có tay nghề cao, người đã thiết kế kiến ​​trúc và bất kỳ phần quan trọng hoặc phức tạp nào của mã. Các thành viên khác trong nhóm làm việc trên thiết kế chi tiết và mã hóa, dưới sự chỉ đạo của lập trình viên trưởng. Như trong Hình 4.3, không có đường truyền nào tồn tại giữa các lập trình viên; tất cả các vấn đề giao tiếp đã được xử lý bởi lập trình viên trưởng. Cuối cùng, lập trình viên trưởng xem xét công việc của các thành viên khác trong nhóm, bởi vì lập trình viên trưởng chịu trách nhiệm cá nhân cho mọi dòng mã.

	Vị trí lập trình viên dự phòng cần thiết chỉ  vì lập trình viên chính là con người và do đó có thể bị ốm, ngã xe buýt hoặc thay đổi công việc. Do đó, lập trình viên dự phòng phải có năng lực như lập trình viên trưởng về mọi mặt và phải biết nhiều về dự án như lập trình viên trưởng. Ngoài ra, để giải phóng người lập trình trưởng tập trung vào thiết kế kiến ​​trúc, lập trình viên dự phòng đã lập kế hoạch trường hợp thử nghiệm hộp đen (Phần 15.11) và các nhiệm vụ khác độc lập với quá trình thiết kế.

	Từ thư ký có một số nghĩa. Thư ký có thể là người hỗ trợ một giám đốc điều hành bận rộn bằng cách trả lời điện thoại, đánh máy thư từ, v.v. Nhưng khi nói về Ngoại trưởng Mỹ hay Ngoại trưởng Anh, chúng ta đề cập đến một trong những thành viên cao cấp nhất của Nội các. Thư ký lập trình không phải là một trợ lý văn thư bán thời gian mà là một thành viên trung tâm có tay nghề cao, được trả lương cao, của nhóm lập trình viên trưởng. Thư ký lập trình chịu trách nhiệm duy trì thư viện sản xuất dự án, tài liệu của dự án. Điều này bao gồm danh sách mã nguồn, JCL và dữ liệu thử nghiệm. Các lập trình viên đã giao mã nguồn của họ cho thư ký, người chịu trách nhiệm chuyển đổi mã nguồn sang dạng máy đọc được, biên dịch, liên kết, tải, thực thi và chạy các trường hợp thử nghiệm. Các lập trình viên do đó không làm gì khác ngoài chương trình. Tất cả các khía cạnh khác trong công việc của họ đều do thư ký chương trình xử lý. (Vì thư ký lập trình duy trì thư viện sản xuất dự án, một số tổ chức đã sử dụng thủ thư chức danh.)

	Hãy nhớ lại rằng những gì được mô tả ở đây là ý tưởng ban đầu của Mills và Baker, có từ năm 1971, khi các phím bấm vẫn còn được sử dụng rộng rãi. Code không còn được thực hiện theo cách đó. Các lập trình viên hiện có các thiết bị đầu cuối hoặc máy trạm riêng để họ code, chỉnh sửa, kiểm tra, v.v. Phiên bản hiện đại của nhóm lập trình trưởng cổ điển được mô tả trong Phần 4.4.

4.3.1 The New York Times Project 
	Khái niệm nhóm lập trình trưởng lần đầu tiên được IBM sử dụng vào năm 1971 để tự động hóa tệp cắt xén (“phòng từ liệu”) của The New York Times. Tệp cắt bớt chứa các bản tóm tắt và các bài báo đầy đủ từ The New York Times và các ấn phẩm khác. Các phóng viên và các thành viên khác trong ban biên tập sử dụng ngân hàng thông tin này như một nguồn thông tin tham khảo.

	Sự thật của dự án là đáng kinh ngạc. Ví dụ, 83.000 dòng code (LOC) đã được thực hiện trong 22 tháng dương lịch, nỗ lực trong 11 năm người. Sau năm đầu tiên, chỉ có hệ thống bảo trì tệp bao gồm 12.000 LOC đã được triển khai. Hầu hết các code được thực hiện trong 6 tháng qua. Chỉ có 21 lỗi được phát hiện trong 5 tuần đầu tiên của quá trình thử nghiệm nghiệm thu; chỉ có 25 lỗi khác được phát hiện trong năm đầu tiên hoạt động. Các lập trình viên chính lấy trung bình một lỗi được phát hiện và 10.000 LOC mỗi người một năm. Hệ thống bảo trì tệp, được cung cấp 1 tuần sau khi mã hóa hoàn thành, hoạt động 20 tháng trước khi phát hiện một lỗi duy nhất. Gần một nửa số chương trình con, thường là 200 đến 400 dòng của PL / I, một ngôn ngữ do IBM phát triển, là đúng trong lần biên dịch đầu tiên [Baker, 1972].

	Tuy nhiên, sau thành công tuyệt vời này, không có tuyên bố nào có thể so sánh được đối với khái niệm nhóm lập trình viên trưởng được đưa ra. Đúng vậy, nhiều dự án thành công đã được thực hiện bằng cách sử dụng đội ngũ lập trình viên chính, nhưng các con số được báo cáo, mặc dù khả quan, không ấn tượng bằng dự án của The New York Times. Tại sao dự án của The New York Times lại thành công như vậy, và tại sao các dự án khác lại không thu được kết quả tương tự?

	Có thể giải thích rằng đây là một dự án uy tín của IBM. Đây là thử nghiệm thực sự đầu tiên cho PLL / I. Một tổ chức được biết đến với các chuyên gia phần mềm xuất sắc, IBM đã thành lập một nhóm bao gồm những gì chỉ có thể được mô tả là crème de la crème từ một bộ phận. Thứ hai, kỹ thuật sao lưu cực kỳ mạnh mẽ. Những người viết trình biên dịch PL / I đã có mặt để hỗ trợ các lập trình viên theo mọi cách họ có thể, và các chuyên gia JCL đã hỗ trợ về ngôn ngữ điều khiển công việc. Một lời giải thích thứ ba có thể là chuyên môn của lập trình viên trưởng, F. Terry Baker. Anh ta bây giờ được gọi là siêu lập trình viên, một lập trình viên có kết quả đầu ra gấp bốn hoặc năm lần so với một lập trình viên giỏi trung bình. Ngoài ra, Baker còn là một nhà quản lý và lãnh đạo tuyệt vời, và các kỹ năng, sự nhiệt tình và cá tính của anh ấy có thể là lý do tạo nên thành công của dự án.

	Nếu lập trình viên trưởng có năng lực, thì tổ chức của nhóm lập trình viên trưởng hoạt động tốt. Mặc dù thành công đáng kể của dự án The New York Times không được lặp lại, nhưng nhiều dự án thành công đã sử dụng các biến thể của phương pháp tiếp cận lập trình viên trưởng. Lý do cho các biến thể cụm từ của cách tiếp cận là nhóm lập trình trưởng cổ điển như được mô tả trong [Baker, 1972] là không thực tế theo nhiều cách.

4.3.2 Impracticality of the Classical Chief Programmer Team Approach
	Hãy xem xét lập trình viên trưởng, sự kết hợp giữa một lập trình viên có tay nghề cao và người quản lý thành công. Những cá nhân như vậy rất khó tìm do thiếu các lập trình viên có kỹ năng cao cũng như thiếu các nhà quản lý thành công; và mô tả công việc của một lập trình viên trưởng đòi hỏi cả hai khả năng. Ngoài ra, những phẩm chất cần thiết để trở thành một lập trình viên có kỹ năng cao dường như khác với những phẩm chất cần thiết để trở thành một nhà quản lý thành công; do đó, cơ hội tìm được một lập trình viên trưởng là rất nhỏ.

	Nếu khó kiếm lập trình viên chính, thì lập trình viên dự phòng cũng hiếm như răng gà mái. Rốt cuộc, lập trình viên dự phòng được kỳ vọng sẽ giỏi như lập trình viên trưởng nhưng phải lùi lại và mức lương thấp hơn trong khi chờ đợi điều gì đó xảy ra với lập trình viên trưởng. Rất ít lập trình viên hàng đầu hoặc nhà quản lý hàng đầu chấp nhận một vai trò như vậy.

	Một thư ký lập trình cũng rất khó tìm. Các chuyên gia phần mềm nổi tiếng với ác cảm với công việc giấy tờ, và thư ký lập trình được cho là sẽ không làm gì ngoài công việc giấy tờ cả ngày.

	Do đó, các nhóm lập trình viên trưởng, ít nhất là theo đề xuất của Baker, là không thực tế để thực hiện. Các đội dân chủ cũng được cho là không thực tế nhưng vì những lý do khác nhau. Hơn nữa, dường như không có kỹ thuật nào có thể xử lý các sản phẩm yêu cầu 20, chứ chưa nói đến 120, lập trình viên cho quy trình cài đặt. Điều cần thiết là một cách tổ chức các nhóm lập trình sử dụng thế mạnh của các nhóm dân chủ và nhóm lập trình trưởng và có thể mở rộng sang việc triển khai các sản phẩm lớn hơn.

 4.4 Beyond Chief Programmer and Democratic Teams 
	Các đội dân chủ có một thế mạnh chính: thái độ tích cực trong việc tìm ra lỗi lầm. Một số tổ chức sử dụng các nhóm lập trình viên trưởng kết hợp với việc xem xét code (Phần 6.2), tạo ra một cạm bẫy tiềm ẩn. Lập trình viên chính chịu trách nhiệm cá nhân cho mọi dòng code và do đó, phải có mặt trong tất cả các lần đánh giá code. Tuy nhiên, một lập trình viên trưởng cũng là một nhà quản lý và, như đã giải thích trong Chương 6, các đánh giá không nên được sử dụng cho bất kỳ loại đánh giá hiệu suất nào. Vì vậy, vì lập trình viên trưởng cũng là người quản lý chịu trách nhiệm về đánh giá chính của các thành viên trong nhóm, nên việc cá nhân đó có mặt trong buổi đánh giá code là điều không thể tránh khỏi.

	Cách giải quyết mâu thuẫn này là loại bỏ phần lớn vai trò quản lý khỏi lập trình viên trưởng. Rốt cuộc, khó khăn trong việc tìm kiếm một cá nhân vừa là lập trình viên có tay nghề cao vừa là nhà quản lý thành công đã được chỉ ra. Thay vào đó, lập trình viên trưởng nên được thay thế bằng hai cá nhân: một trưởng nhóm phụ trách các khía cạnh kỹ thuật của các hoạt động của nhóm và một người quản lý nhóm chịu trách nhiệm về tất cả các quyết định của người quản lý phi kỹ thuật. Cấu trúc của nhóm kết quả được thể hiện trong Hình 4.4. Điều quan trọng là nhận ra rằng cơ cấu tổ chức này không vi phạm nguyên tắc quản lý cơ bản là không nhân viên nào phải báo cáo với nhiều hơn một người quản lý. Các lĩnh vực trách nhiệm được phân định rõ ràng. Trưởng nhóm chỉ chịu trách nhiệm quản lý kỹ thuật. Do đó, các vấn đề về ngân sách và pháp lý không được trưởng nhóm xử lý cũng như không phải là đánh giá hiệu quả hoạt động. Mặt khác, trưởng nhóm có trách nhiệm duy nhất về các vấn đề kỹ thuật. Do đó, người quản lý nhóm không có quyền hứa, chẳng hạn như sản phẩm sẽ được giao trong vòng 4 tuần; những lời hứa kiểu đó phải được thực hiện bởi trưởng nhóm. Trưởng nhóm đương nhiên tham gia vào tất cả các cuộc đánh giá mã; xét cho cùng, người đó chịu trách nhiệm cá nhân về mọi khía cạnh của mã. Đồng thời, người quản lý nhóm không được phép đánh giá vì đánh giá hiệu suất của lập trình viên là một chức năng của người quản lý nhóm. Thay vào đó, người quản lý nhóm thu nhận kiến ​​thức về các kỹ năng kỹ thuật của từng lập trình viên trong nhóm trong các cuộc họp nhóm được lên lịch thường xuyên.

	Trước khi bắt đầu thực hiện, điều quan trọng là phải phân định ranh giới rõ ràng những khu vực dường như thuộc trách nhiệm của cả người quản lý nhóm và trưởng nhóm. Ví dụ, hãy xem xét vấn đề nghỉ phép hàng năm. Tình huống có thể phát sinh rằng người quản lý nhóm phê duyệt đơn xin nghỉ việc vì nghỉ phép là một vấn đề không liên quan đến kỹ thuật, chỉ để tìm thấy đơn xin được phủ quyết bởi trưởng nhóm vì thời hạn đang đến gần. Giải pháp cho vấn đề này và các vấn đề liên quan là quản lý cấp cao hơn phải đưa ra chính sách liên quan đến các lĩnh vực mà cả quản lý nhóm và trưởng nhóm đều coi là trách nhiệm của họ.

	Còn những dự án lớn hơn thì sao? Cách tiếp cận này có thể được mở rộng như trong Hình 4.5, cho thấy cơ cấu tổ chức quản lý kỹ thuật; phía phi kỹ thuật cũng được tổ chức tương tự. Việc thực hiện toàn bộ sản phẩm dưới sự chỉ đạo của trưởng dự án. Các lập trình viên báo cáo cho trưởng nhóm của họ, và các trưởng nhóm báo cáo cho trưởng dự án. Đối với các sản phẩm thậm chí lớn hơn, các cấp bổ sung có thể được thêm vào hệ thống phân cấp.

	Một cách khác để rút ra những đặc điểm tốt nhất của cả nhóm lập trình viên dân chủ và trưởng nhóm là phân cấp quá trình ra quyết định khi thích hợp. Các kênh liên lạc kết quả được thể hiện trong Hình 4.6. Sơ đồ này hữu ích cho các loại vấn đề mà cách tiếp cận dân chủ là tốt, nghĩa là, trong môi trường nghiên cứu hoặc bất cứ khi nào một vấn đề khó đòi hỏi tác động hiệp đồng của sự tương tác nhóm để giải quyết nó. Bất chấp sự phân quyền, các mũi tên từ cấp này sang cấp khác vẫn hướng xuống; cho phép các lập trình viên ra lệnh cho người lãnh đạo dự án chỉ có thể dẫn đến sự hỗn loạn.

4.5 Synchronize-and-Stabilize Teams 
	Một cách tiếp cận thay thế để tổ chức nhóm là nhóm đồng bộ hóa và ổn định được sử dụng bởi Microsoft [Cusumano và Selby, 1997]. Microsoft xây dựng các sản phẩm lớn; ví dụ, Windows 2000 bao gồm hơn 30 triệu dòng mã, được xây dựng bởi hơn 3000 lập trình viên và người kiểm tra, sử dụng lại phần lớn Windows NT 4.0 [Business Week Online, 1999]. Tổ chức nhóm là một khía cạnh quan trọng của việc xây dựng thành công một sản phẩm ở quy mô này.

	Mô hình vòng đời đồng bộ hóa và ổn định được mô tả trong Phần 2.9.6. Sự thành công của mô hình này phần lớn là hệ quả của cách tổ chức các đội. Mỗi phiên bản trong số ba hoặc bốn bản dựng tuần tự của mô hình đồng bộ hóa và ổn định được xây dựng bởi một số nhóm nhỏ song song do người quản lý dẫn đầu và bao gồm từ ba đến tám nhà phát triển cùng với ba đến tám người thử nghiệm làm việc 1-1 với các nhà phát triển. Nhóm được cung cấp các thông số kỹ thuật của nhiệm vụ tổng thể của mình; các thành viên trong nhóm cá nhân sau đó có quyền tự do thiết kế và thực hiện các phần của nhiệm vụ đó như họ muốn. Lý do mà điều này không nhanh chóng chuyển thành hỗn loạn do hacker gây ra là bước đồng bộ hóa được thực hiện mỗi ngày: Các thành phần đã hoàn thành một phần được kiểm tra và gỡ lỗi hàng ngày. Theo đó, mặc dù sự sáng tạo và quyền tự chủ của cá nhân được nuôi dưỡng, các thành phần cá nhân luôn làm việc cùng nhau.

	Điểm mạnh của cách tiếp cận này là, một mặt, các lập trình viên cá nhân được khuyến khích sáng tạo và đổi mới, một đặc điểm của một nhóm dân chủ. Mặt khác, bước đồng bộ hóa hàng ngày đảm bảo rằng hàng trăm nhà phát triển làm việc cùng nhau hướng tới một mục tiêu chung mà không yêu cầu đặc tính giao tiếp và phối hợp của nhóm lập trình viên chính (Hình 4.3).

	Các nhà phát triển của Microsoft phải tuân theo rất ít quy tắc, nhưng một trong số đó là họ phải tuân thủ nghiêm ngặt thời gian quy định để nhập mã của họ vào cơ sở dữ liệu sản phẩm để đồng bộ hóa ngày hôm đó. Cusumano và Selby [1997] ví điều này giống như việc nói với trẻ rằng chúng có thể làm những gì chúng thích cả ngày nhưng phải ở trên giường trước 9 giờ tối. Một quy tắc khác là, nếu mã của nhà phát triển ngăn không cho sản phẩm được biên dịch để đồng bộ hóa ngày hôm đó, thì sự cố phải được khắc phục ngay lập tức để những người còn lại trong nhóm có thể kiểm tra và gỡ lỗi công việc của ngày hôm đó.

	Liệu việc sử dụng mô hình đồng bộ hóa và ổn định và tổ chức nhóm liên quan có đảm bảo rằng mọi tổ chức phần mềm khác sẽ thành công như Microsoft không? Điều này là cực kỳ khó xảy ra. Microsoft, Inc., không chỉ là mô hình đồng bộ hóa và ổn định. Nó là một tổ chức bao gồm một tập hợp các nhà quản lý và nhà phát triển phần mềm tài năng cao với các đặc tính nhóm phát triển. Chỉ sử dụng mô hình đồng bộ hóa và ổn định sẽ không biến một tổ chức thành một Microsoft khác một cách kỳ diệu. Đồng thời, việc sử dụng nhiều tính năng của mô hình trong các tổ chức khác có thể dẫn đến cải tiến quy trình. Mặt khác, có ý kiến ​​cho rằng mô hình đồng bộ hóa và ổn định chỉ đơn giản là một cách cho phép một nhóm tin tặc phát triển các sản phẩm lớn và thành công của Microsoft là nhờ hoạt động tiếp thị xuất sắc chứ không phải phần mềm chất lượng.

 4.6 Teams for Agile Processes
 Phần 2.9.5 giới thiệu tổng quan về các quy trình nhanh [Beck và cộng sự, 2001]. Trong phần này, chúng tôi mô tả cách tổ chức các nhóm khi sử dụng các quy trình nhanh.

	Một đặc điểm hơi khác thường của các quy trình nhanh là tất cả mã được thực hiện bởi một nhóm hai lập trình viên dùng chung một máy tính; điều này được gọi là lập trình cặp [Williams, Kessler, Cunningham, và Jeffries, 2000]. Các lý do cho cách tiếp cận này bao gồm:
	• Như đã giải thích trong Phần 2.9.5, trước tiên, các lập trình viên ghép nối tạo ra các trường hợp kiểm thử và sau đó thực hiện đoạn mã (nhiệm vụ) đó. Như đã giải thích trong Phần 6.6, lập trình viên rất khó kiểm tra mã của chính mình. Các quy trình Agile giải quyết vấn đề này bằng cách để một cặp lập trình viên trong một nhóm vẽ các trường hợp thử nghiệm cho một nhiệm vụ và lập trình viên cặp kia cùng triển khai mã bằng các trường hợp thử nghiệm đó.
	• Trong một mô hình vòng đời thông thường hơn, khi một nhà phát triển rời khỏi một dự án, tất cả kiến ​​thức mà nhà phát triển đó tích lũy được cũng sẽ rời đi. Đặc biệt, phần mềm mà nhà phát triển đó đang làm việc có thể chưa được ghi lại và có thể phải được phát triển lại từ đầu. Ngược lại, nếu một thành viên của nhóm lập trình theo cặp rời đi, người còn lại có đủ kiến ​​thức để tiếp tục làm việc trên cùng một phần của phần mềm với một lập trình viên theo cặp mới. Hơn nữa, sự hiện diện của các trường hợp thử nghiệm giúp làm nổi bật một lỗi, nếu nhóm mới vô tình làm hỏng phần mềm bằng cách thực hiện một sửa đổi không được khuyến cáo.
	• Làm việc chặt chẽ theo cặp cho phép một chuyên gia phần mềm ít kinh nghiệm hơn có được các kỹ năng của thành viên nhóm nhiều kinh nghiệm hơn.
	• Như đã đề cập trong Phần 2.9.5, tất cả các máy tính được sử dụng bởi các nhóm cặp khác nhau được đặt cùng nhau ở giữa một căn phòng lớn. Điều này thúc đẩy quyền sở hữu mã của nhóm, một đặc điểm tích cực của các nhóm vô vị lợi (Phần 4.2).

	Vì vậy, mặc dù ý tưởng về việc hai lập trình viên làm việc cùng nhau trên cùng một máy tính có vẻ hơi khác thường, nhưng việc thực hành này có thể có những lợi thế khác biệt.

	Một thử nghiệm thú vị về lập trình cặp được mô tả trong [Arisholm, Gallis, Dybå, và Sjøberg, 2007]. Tổng cộng 295 lập trình viên chuyên nghiệp (99 cá nhân và 98 cặp) đã được thuê để tham gia một thử nghiệm kéo dài một ngày được tiến hành cẩn thận về lập trình cặp. Các đối tượng được yêu cầu thực hiện một số nhiệm vụ bảo trì trên hai sản phẩm phần mềm Java, một đơn giản và một phức tạp. Cặp lập trình viên yêu cầu nỗ lực nhiều hơn 84% để thực hiện các nhiệm vụ một cách chính xác. Theo kết quả này, một số kỹ sư phần mềm có thể xem xét lại việc sử dụng lập trình cặp và do đó, các quy trình nhanh.

	Hơn nữa, như đã nêu trong Phần 2.9.5, một phân tích của 15 nghiên cứu đã xuất bản đã so sánh hiệu quả của lập trình cá nhân và lập trình cặp [Dybå et al., 2007] và đi đến kết luận rằng nó phụ thuộc vào cả chuyên môn của lập trình viên và độ phức tạp của hệ thống và các công việc cụ thể cần giải quyết. Rõ ràng, cần phải tiến hành nhiều nghiên cứu hơn, tốt nhất là thực hiện trên số lượng lớn các lập trình viên chuyên nghiệp trong lĩnh vực này.

4.7 Open-Source Programming Teams
	Điều đáng ngạc nhiên là bất kỳ dự án mã nguồn mở nào cũng thành công, chưa kể một số sản phẩm phần mềm thành công nhất từng được phát triển sử dụng mô hình vòng đời mã nguồn mở. Rốt cuộc, các dự án nguồn mở thường được biên chế bởi các nhóm tình nguyện viên không được trả lương. Họ giao tiếp không đồng bộ (tức là qua e-mail), không có cuộc họp nhóm và không có người quản lý - tính không chính thức thống trị ở mọi khía cạnh. Hơn nữa, không có thông số kỹ thuật hoặc thiết kế nào tồn tại; trên thực tế, tài liệu về bất kỳ loại nào là cực kỳ hiếm, ngay cả trong các dự án trưởng thành. Nhưng bất chấp những trở ngại hầu như không thể vượt qua này, một số lượng nhỏ các dự án mã nguồn mở như Linux và Apache đã đạt được mức độ thành công cao nhất.

	Các cá nhân tình nguyện tham gia vào một dự án mã nguồn mở vì hai lý do chính: vì sự thích thú tuyệt đối khi hoàn thành một nhiệm vụ đáng giá, hoặc vì trải nghiệm học tập.
	• Để thu hút các tình nguyện viên tham gia một dự án mã nguồn mở và khiến họ quan tâm, điều cần thiết là họ luôn xem dự án là “đáng giá”. Các cá nhân không có khả năng dành một phần đáng kể thời gian rảnh rỗi của họ cho một dự án trừ khi họ thực sự tin rằng dự án sẽ thành công và sản phẩm sẽ được sử dụng rộng rãi. Những người tham gia sẽ bắt đầu lạc lối nếu họ bắt đầu coi dự án là vô ích.
	• Về lý do thứ hai, nhiều chuyên gia phần mềm tham gia một dự án mã nguồn mở để đạt được kỹ năng về một công nghệ mới đối với họ, chẳng hạn như ngôn ngữ lập trình hiện đại hoặc hệ điều hành mà họ không quen thuộc. Sau đó, họ có thể tận dụng kiến ​​thức thu được để được thăng tiến trong tổ chức của mình hoặc có được vị trí tốt hơn trong một tổ chức khác. Xét cho cùng, các nhà tuyển dụng thường coi kinh nghiệm đạt được khi làm việc trong một dự án mã nguồn mở lớn, thành công là điều đáng mong đợi hơn là đạt được các bằng cấp học vấn bổ sung. Ngược lại, chẳng ích gì khi dành nhiều tháng làm việc chăm chỉ cho một dự án mà cuối cùng lại thất bại.

	Nói cách khác, trừ khi một dự án luôn được coi là người chiến thắng, nó sẽ không thu hút và giữ chân những người tình nguyện làm việc trong dự án đó. Hơn nữa, các thành viên của nhóm nguồn mở luôn phải cảm thấy rằng họ đang đóng góp. Vì tất cả những lý do này, điều cần thiết là cá nhân chủ chốt đằng sau một dự án mã nguồn mở phải là một động lực tuyệt vời. Trừ khi trường hợp này xảy ra, dự án chắc chắn sẽ thất bại.

	Một điều kiện tiên quyết khác để phát triển mã nguồn mở thành công là kỹ năng của các thành viên trong nhóm. Như đã giải thích chi tiết trong Phần 9.2, có sự khác biệt lớn về trình độ kỹ năng giữa các lập trình viên. Ghi nhớ những trở ngại để sản xuất thành công phần mềm nguồn mở được liệt kê trong đoạn đầu tiên của phần này, hầu như không có cách nào mà một dự án nguồn mở có thể thành công trừ khi các thành viên của nhóm cốt lõi (Phần 2.9.4) là những người hàng đầu- những cá nhân tầm cỡ với những kỹ năng được mài dũa tinh xảo của bậc cao nhất. Những cá nhân hàng đầu như vậy sẽ phát triển mạnh trong hầu hết mọi môi trường, kể cả môi trường không có cấu trúc như một nhóm nguồn mở.

	Nói cách khác, một dự án mã nguồn mở thành công vì bản chất của sản phẩm mục tiêu, tính cách của kẻ chủ mưu và tài năng của các thành viên trong nhóm cốt lõi. Cách tổ chức một nhóm mã nguồn mở thành công về cơ bản là không liên quan.

4.8 People Capability Maturity Model 
	Mô hình phát triển năng lực con người (P – CMM) mô tả các phương pháp hay nhất để quản lý và phát triển lực lượng lao động của một tổ chức [Curtis, Hefley, and Miller, 2002]. Như với mô hình phát triển năng lực phần mềm, SW – CMM (Phần 3.13), một tổ chức tiến triển qua năm cấp độ trưởng thành với mục đích liên tục cải thiện các kỹ năng cá nhân và hình thành các nhóm hiệu quả.

	Mỗi cấp độ trưởng thành đều có các lĩnh vực quy trình chính (KPA) của riêng nó, mỗi lĩnh vực trong số đó cần được giải quyết thỏa đáng trước khi một tổ chức có thể được coi là đã đạt được cấp độ trưởng thành đó. Ví dụ: đối với cấp độ 2, cấp độ được quản lý, các KPA là nhân sự, giao tiếp và điều phối, môi trường làm việc, quản lý hiệu suất, đào tạo và phát triển và lương thưởng. Ngược lại, KPA cho cấp độ 5, cấp độ tối ưu hóa, là cải tiến năng lực liên tục, điều chỉnh hiệu suất tổ chức và liên tục đổi mới lực lượng lao động.

	SW – CMM là một khuôn khổ để cải thiện quy trình phần mềm của tổ chức — không khuyến nghị quy trình hoặc phương pháp cụ thể nào. Theo cách tương tự, P-CMM là một khuôn khổ để cải thiện các quy trình của một tổ chức để quản lý và phát triển lực lượng lao động của mình và không có phương pháp tiếp cận cụ thể nào đối với tổ chức nhóm được đưa ra

4.9 Choosing an Appropriate Team Organization 
	vấn đề tổ chức đội cho tất cả các quy trình công việc khác. Cách tổ chức nhóm tối ưu phụ thuộc vào sản phẩm được xây dựng, kinh nghiệm trước đó với các cấu trúc nhóm khác nhau, và quan trọng nhất là văn hóa của tổ chức. Ví dụ, nếu quản lý cấp cao không thoải mái với việc ra quyết định phi tập trung, thì nó sẽ không được thực hiện.

	Trên thực tế, hầu hết các đội hiện được tổ chức như mô tả trong Phần 4.4. Đó là, một số biến thể của nhóm lập trình viên trưởng là thông lệ thường thấy.

	Chưa có nhiều nghiên cứu về tổ chức nhóm phát triển phần mềm và nhiều nguyên tắc được chấp nhận chung là dựa trên nghiên cứu về động lực của nhóm nói chung chứ không phải nhóm phát triển phần mềm. Ngay cả khi các nghiên cứu về nhóm phần mềm đã được thực hiện, kích thước mẫu nhìn chung vẫn nhỏ nên kết quả chưa thuyết phục.

	Cho đến khi thu được các kết quả thử nghiệm về tổ chức nhóm trong ngành công nghiệp phần mềm, sẽ không dễ dàng để xác định tổ chức nhóm tối ưu cho một sản phẩm cụ thể.



